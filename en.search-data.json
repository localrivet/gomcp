{"/clients/":{"data":{"":"","#":"The gomcp library provides tools for building applications that act as MCP clients. An MCP client connects to an MCP server to discover and utilize the server’s capabilities, such as executing tools, accessing resources, and retrieving prompt templates.\nThe core client logic is implemented in the gomcp/client package. This package provides a high-level Client struct that manages the connection, handles the MCP handshake, and provides methods for interacting with the server. The Client struct works with various underlying transport mechanisms, which are covered in detail in the Client Transports section below.\nClient Role An MCP client application typically performs the following tasks:\nConnect to a Server: Establish a communication link with a known MCP server endpoint using a specific transport (Stdio, SSE+HTTP, WebSocket, TCP). Initialize the Session: Perform the MCP initialization handshake (initialize request and initialized notification) to exchange capabilities and establish the session. Discover Capabilities: Query the server to discover the available tools (tools/list), resources (resources/list), and prompts (prompts/list). Execute Tools: Call specific tools on the server (tools/call) to perform actions or computations, providing necessary arguments and handling the results. Access Resources: Retrieve the content of resources from the server (resources/read) to obtain contextual data. Subscribe to Updates: Subscribe to resource updates (resources/subscribe) to receive notifications when resource content or metadata changes (notifications/resources/updated). Retrieve Prompts: Get the definition of prompt templates from the server (prompts/get), potentially with arguments substituted. Handle Server Messages: Process asynchronous messages from the server, such as progress notifications ($/progress), logging messages (notifications/message), or resource updates. Initializing the Client (client package) To create an MCP client, you use one of the transport-specific constructors provided by the client package. These constructors return a *client.Client instance configured to use the specified transport.\nHere’s a general example using a placeholder for the transport constructor (refer to Client Transports for specific transport examples):\npackage main import ( \"context\" \"log\" \"os\" \"time\" \"github.com/localrivet/gomcp/client\" \"github.com/localrivet/gomcp/protocol\" ) func main() { // Configure logger (optional) log.SetOutput(os.Stderr) log.SetFlags(log.Ltime | log.Lshortfile) log.Println(\"Starting MCP Client...\") // 1. Create Client Instance using a transport constructor // Example using NewStdioClient (replace with appropriate transport constructor) clt, err := client.NewStdioClient(\"MyClient\", client.ClientOptions{ // Optional: Customize client capabilities or provide a logger // ClientCapabilities: protocol.ClientCapabilities{ /* ... */ }, // Logger: myCustomLogger, // PreferredProtocolVersion: \u0026protocol.CurrentProtocolVersion, }) if err != nil { log.Fatalf(\"Failed to create client: %v\", err) } // Ensure the client connection is closed when main exits defer clt.Close() // Use a context for the connection and requests ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second) defer cancel() // 2. Connect to the server and perform the initialization handshake log.Println(\"Connecting to server...\") err = clt.Connect(ctx) if err != nil { log.Fatalf(\"Failed to connect and initialize with server: %v\", err) } log.Printf(\"Connected to server: %s (Version: %s)\", clt.ServerInfo().Name, clt.ServerInfo().Version) log.Printf(\"Server capabilities: %+v\", clt.ServerCapabilities()) // --- Client is now ready to make requests --- // Example: List available tools from the server log.Println(\"Listing available tools...\") toolsResult, err := clt.ListTools(ctx, protocol.ListToolsRequestParams{}) if err != nil { log.Printf(\"Error listing tools: %v\", err) } else { log.Printf(\"Available tools (%d):\", len(toolsResult.Tools)) for _, tool := range toolsResult.Tools { log.Printf(\"- %s: %s\", tool.Name, tool.Description) } } // Example: Call the \"echo\" tool log.Println(\"Calling 'echo' tool...\") callToolParams := protocol.CallToolParams{ Name: \"echo\", Arguments: map[string]interface{}{ \"input\": \"Hello from the client!\", }, } callToolResult, err := clt.CallTool(ctx, callToolParams) if err != nil { log.Printf(\"Error calling tool 'echo': %v\", err) } else { log.Println(\"Tool 'echo' returned content:\") for _, content := range callToolResult.Content { // Assuming TextContent for this example if textContent, ok := content.(protocol.TextContent); ok { log.Printf(\"- %s: %s\", textContent.Type, textContent.Text) } else { log.Printf(\"- Received content of type: %s\", content.GetContentType()) } } if callToolResult.IsError != nil \u0026\u0026 *callToolResult.IsError { log.Println(\"Tool execution reported an error.\") } } // Example: List available resources log.Println(\"Listing available resources...\") resourcesResult, err := clt.ListResources(ctx, protocol.ListResourcesRequestParams{}) if err != nil { log.Printf(\"Error listing resources: %v\", err) } else { log.Printf(\"Available resources (%d):\", len(resourcesResult.Resources)) for _, resource := range resourcesResult.Resources { log.Printf(\"- %s (Kind: %s, Version: %s)\", resource.URI, resource.Kind, resource.Version) } } // Example: List available prompts log.Println(\"Listing available prompts...\") promptsResult, err := clt.ListPrompts(ctx, protocol.ListPromptsRequestParams{}) if err != nil { log.Printf(\"Error listing prompts: %v\", err) } else { log.Printf(\"Available prompts (%d):\", len(promptsResult.Prompts)) for _, prompt := range promptsResult.Prompts { log.Printf(\"- %s (Title: %s)\", prompt.URI, prompt.Title) } } log.Println(\"Client operations finished.\") } The client.ClientOptions struct allows you to configure the client’s name, specify its capabilities, provide a custom logger, or set a preferred protocol version for the handshake.\nThe Connect method establishes the connection and performs the MCP initialization handshake. It blocks until the handshake is complete or an error occurs. You should always call Connect before attempting to send any other requests.\nMaking Requests Once the client is connected and initialized, you can use the methods provided by the *client.Client instance to interact with the server. Each request method takes a context.Context for cancellation and deadlines, and a parameters struct defined in the gomcp/protocol package.\nHere are some common request methods:\nListTools(ctx context.Context, params protocol.ListToolsRequestParams) (*protocol.ListToolsResult, error): Retrieves a list of available tools from the server. CallTool(ctx context.Context, params protocol.CallToolParams) (*protocol.CallToolResult, error): Requests the server to execute a specific tool with the given arguments. ListResources(ctx context.Context, params protocol.ListResourcesRequestParams) (*protocol.ListResourcesResult, error): Retrieves a list of available resources from the server. GetResource(ctx context.Context, params protocol.ReadResourceRequestParams) (*protocol.ReadResourceResult, error): Retrieves the content of a specific resource. SubscribeResources(ctx context.Context, params protocol.SubscribeResourceParams) (*protocol.SubscribeResourceResult, error): Subscribes to updates for a list of resources. UnsubscribeResources(ctx context.Context, params protocol.UnsubscribeResourceParams) (*protocol.UnsubscribeResourceResult, error): Unsubscribes from updates for a list of resources. ListPrompts(ctx context.Context, params protocol.ListPromptsRequestParams) (*protocol.ListPromptsResult, error): Retrieves a list of available prompt templates. GetPrompt(ctx context.Context, params protocol.GetPromptRequestParams) (*protocol.GetPromptResult, error): Retrieves the definition of a specific prompt, potentially with arguments substituted. SendCancellation(ctx context.Context, id interface{}) error: Sends a cancellation notification for a previously sent request with the given ID. SendProgress(ctx context.Context, params protocol.ProgressParams) error: Sends a progress notification (if the client is performing a long-running operation that the server is monitoring). Refer to the relevant sections below for detailed information on the parameters and results for each method.","client-protocol-methods#Client Protocol Methods":"This section details the specific JSON-RPC messages used by clients to interact with Resources and Prompts on the server.\nResource Methods Clients interact with Resources using the following methods:\nresources/list Request Clients send the resources/list request to discover the resources available on the server.\nMethod: \"resources/list\" Parameters: protocol.ListResourcesRequestParams Result: protocol.ListResourcesResult type ListResourcesRequestParams struct { Filter map[string]interface{} `json:\"filter,omitempty\"` // Optional filtering criteria Cursor string `json:\"cursor,omitempty\"` // For pagination } type ListResourcesResult struct { Resources []Resource `json:\"resources\"` NextCursor string `json:\"nextCursor,omitempty\"` // For pagination } Clients can optionally provide Filter criteria to narrow down the list of returned resources and a Cursor for pagination. The server responds with a list of protocol.Resource definitions.\nresources/read Request Clients send the resources/read request to retrieve the actual content of a specific resource.\nMethod: \"resources/read\" Parameters: protocol.ReadResourceRequestParams Result: protocol.ReadResourceResult type ReadResourceRequestParams struct { URI string `json:\"uri\"` // The URI of the resource to read Version string `json:\"version,omitempty\"` // Optional version hint Meta *RequestMeta `json:\"_meta,omitempty\"` // Optional metadata like progress token } type ReadResourceResult struct { Resource Resource `json:\"resource\"` // The resource metadata (may be updated) Contents ResourceContents `json:\"contents\"` // The actual content (Text or Blob) Meta *RequestMeta `json:\"_meta,omitempty\"` // Optional metadata from the server } URI: The URI of the resource whose content is requested. Version: An optional version string that the client has cached. The server can use this as a hint but should return the latest version if available. Meta: Optional metadata, including a ProgressToken if the client wishes to receive progress updates for this read operation. The server responds with a ReadResourceResult containing the resource’s metadata (which might be updated) and the actual Contents. The Contents field will contain an object implementing the protocol.ResourceContents interface, such as protocol.TextResourceContents or protocol.BlobResourceContents.\nresources/subscribe Request Clients can subscribe to resource updates to be notified when a resource’s content or metadata changes.\nMethod: \"resources/subscribe\" Parameters: protocol.SubscribeResourceParams Result: protocol.SubscribeResourceResult (currently empty) type SubscribeResourceParams struct { URIs []string `json:\"uris\"` // List of resource URIs to subscribe to } type SubscribeResourceResult struct{} // Currently empty Clients provide a list of resource URIs they want to subscribe to. The server tracks these subscriptions per session.\nresources/unsubscribe Request Clients can unsubscribe from resource updates.\nMethod: \"resources/unsubscribe\" Parameters: protocol.UnsubscribeResourceParams Result: protocol.UnsubscribeResourceResult (currently empty) type UnsubscribeResourceParams struct { URIs []string `json:\"uris\"` // List of resource URIs to unsubscribe from } type UnsubscribeResourceResult struct{} // Currently empty Clients provide a list of resource URIs they no longer wish to receive updates for.\nnotifications/resources/updated Notification Servers send the notifications/resources/updated notification to inform subscribed clients that a specific resource has been updated.\nMethod: \"notifications/resources/updated\" Parameters: protocol.ResourceUpdatedParams type ResourceUpdatedParams struct { Resource Resource `json:\"resource\"` // The updated resource metadata } The server includes the updated protocol.Resource metadata in the notification. Clients can then decide whether to re-read the resource content using resources/read.\nnotifications/resources/list_changed Notification Servers can send the notifications/resources/list_changed notification to inform clients that the list of available resources has changed (resources added or removed).\nMethod: \"notifications/resources/list_changed\" Parameters: protocol.ResourcesListChangedParams (currently empty) type ResourcesListChangedParams struct{} // Currently empty This notification does not include the updated list itself, only signals that a change has occurred. Clients must send a resources/list request to get the new list.\nPrompt Methods Clients interact with Prompts using the following methods:\nprompts/list Request Clients send the prompts/list request to discover the prompt templates available on the server.\nMethod: \"prompts/list\" Parameters: protocol.ListPromptsRequestParams Result: protocol.ListPromptsResult type ListPromptsRequestParams struct { Filter map[string]interface{} `json:\"filter,omitempty\"` // Optional filtering criteria Cursor string `json:\"cursor,omitempty\"` // For pagination } type ListPromptsResult struct { Prompts []Prompt `json:\"prompts\"` NextCursor string `json:\"nextCursor,omitempty\"` // For pagination } Clients can optionally provide Filter criteria and a Cursor for pagination. The server responds with a list of protocol.Prompt definitions (metadata and message structure with placeholders).\nprompts/get Request Clients send the prompts/get request to retrieve the full definition of a specific prompt, with provided arguments substituted into the message content.\nMethod: \"prompts/get\" Parameters: protocol.GetPromptRequestParams Result: protocol.GetPromptResult type GetPromptRequestParams struct { URI string `json:\"uri\"` // The URI of the prompt to retrieve Arguments map[string]interface{} `json:\"arguments,omitempty\"` // Arguments to substitute into the template } type GetPromptResult struct { Prompt Prompt `json:\"prompt\"` // The prompt definition with arguments substituted } URI: The URI of the prompt template to retrieve. Arguments: A map of argument names and their values to be substituted into the prompt template’s message content. The server performs the argument substitution in the message content and responds with a GetPromptResult containing the updated protocol.Prompt struct.\nnotifications/prompts/list_changed Notification Servers can send the notifications/prompts/list_changed notification to inform clients that the list of available prompts has changed and they should re-list if they need the updated list.\nMethod: \"notifications/prompts/list_changed\" Parameters: protocol.PromptsListChangedParams (currently empty) type PromptsListChangedParams struct{} // Currently empty This notification does not include the updated list itself, only signals that a change has occurred. Clients must send a prompts/list request to get the new list.\nHandling Server Messages MCP servers can send asynchronous messages to clients, such as notifications or server-initiated requests. You can register handlers for these messages using the RegisterNotificationHandler and RegisterRequestHandler methods on the client.Client instance before calling Connect.\n// Example of registering a notification handler clt.RegisterNotificationHandler(protocol.MethodProgress, func(ctx context.Context, params interface{}) error { // Handle incoming progress notifications progressParams, ok := params.(protocol.ProgressParams) if !ok { log.Printf(\"Received progress notification with unexpected params type: %T\", params) return nil // Or return an error if strict type checking is needed } log.Printf(\"Received progress update for token %v: %+v\", progressParams.Token, progressParams.Value) return nil }) // Example of registering a server-initiated request handler (less common) // clt.RegisterRequestHandler(\"server/doSomething\", func(ctx context.Context, id interface{}, params interface{}) (interface{}, error) { // // Handle server's request and return a result or error // log.Printf(\"Received server request 'server/doSomething' with ID %v and params %+v\", id, params) // // ... process request ... // return map[string]string{\"status\": \"done\"}, nil // Example success result // }) By implementing these handlers, your client application can react to events and requests initiated by the MCP server.","client-transports#Client Transports":"GoMCP clients can connect to MCP servers using various transport mechanisms. The choice of transport depends on how the server is configured to listen for connections and the specific requirements of your application (e.g., local communication vs. network communication, protocol version compatibility). The gomcp/client package provides constructors for the supported transports, abstracting away the low-level communication details.\nChoosing a Transport Select the transport that corresponds to the server you are connecting to:\nStdio: For communicating with a server running as a local child process, piping standard input/output. SSE + HTTP: For connecting to servers implementing the 2024-11-05 protocol’s HTTP+SSE transport model (HTTP POST for requests, SSE for server-to-client messages). WebSocket: For connecting to servers implementing the 2025-03-26 protocol’s Streamable HTTP transport model (single WebSocket connection for all messages). TCP: A lower-level option for raw TCP socket communication. Stdio Transport The Stdio transport facilitates communication over standard input and output streams. This is particularly useful for:\nLocal Inter-Process Communication: When your client application launches and manages the server as a child process. Simple Examples and Testing: Provides an easy way to demonstrate basic MCP communication without network setup. To create a client using the Stdio transport, use the client.NewStdioClient constructor:\npackage main import ( \"context\" \"log\" \"os\" \"time\" \"github.com/localrivet/gomcp/client\" ) func main() { log.SetOutput(os.Stderr) log.SetFlags(log.Ltime | log.Lshortfile) log.Println(\"Starting Stdio Client...\") // Create a client instance for the stdio transport // Provide a client name and optional ClientOptions clt, err := client.NewStdioClient(\"MyStdioClient\", client.ClientOptions{ // Optional configurations can go here // Logger: myCustomLogger, }) if err != nil { log.Fatalf(\"Failed to create stdio client: %v\", err) } // Ensure the client connection is closed when main exits defer clt.Close() ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second) defer cancel() // Connect to the server and perform the initialization handshake log.Println(\"Connecting to server via stdio...\") err = clt.Connect(ctx) if err != nil { log.Fatalf(\"Failed to connect and initialize: %v\", err) } log.Printf(\"Connected to server: %s\", clt.ServerInfo().Name) // Client is now ready to make requests using the 'clt' instance // ... example requests like ListTools, CallTool, etc. ... log.Println(\"Client operations finished.\") } When using Stdio, the client typically writes JSON-RPC messages to standard output, which are read by the server from its standard input, and vice-versa.\nSSE + HTTP Hybrid Transport This transport is designed for network communication and is compatible with servers implementing the transport model introduced in the 2024-11-05 protocol specification. It utilizes:\nHTTP POST: For the client to send requests (like initialize, tools/call). Server-Sent Events (SSE): For the server to send asynchronous messages (like initialize responses, notifications, server-initiated requests) to the client over a persistent connection. To create a client for this transport, use the client.NewSSEClient constructor:\npackage main import ( \"context\" \"log\" \"os\" \"time\" \"github.com/localrivet/gomcp/client\" ) func main() { log.SetOutput(os.Stderr) log.SetFlags(log.Ltime | log.Lshortfile) log.Println(\"Starting SSE Client...\") // Server's base URL (e.g., http://localhost:8080) baseURL := \"http://localhost:8080\" // The base path for MCP endpoints on the server (e.g., /mcp) basePath := \"/mcp\" // Create a client instance for the SSE transport clt, err := client.NewSSEClient(\"MySSEClient\", baseURL, basePath, client.ClientOptions{ // Optional configurations }) if err != nil { log.Fatalf(\"Failed to create SSE client: %v\", err) } defer clt.Close() ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second) defer cancel() // Connect to the server and perform the initialization handshake log.Println(\"Connecting to server via SSE+HTTP...\") err = clt.Connect(ctx) if err != nil { log.Fatalf(\"Failed to connect and initialize: %v\", err) } log.Printf(\"Connected to server: %s\", clt.ServerInfo().Name) // Client is now ready to make requests using the 'clt' instance // ... example requests ... log.Println(\"Client operations finished.\") } This transport is suitable for web-based clients or environments where SSE is a preferred mechanism for server-push.\nWebSocket Transport The WebSocket transport is the recommended network transport for servers implementing the 2025-03-26 protocol specification’s “Streamable HTTP” model. It uses a single, full-duplex WebSocket connection for all communication, allowing both client and server to send messages asynchronously over the same connection.\nTo create a client for this transport, use the client.NewWebSocketClient constructor:\npackage main import ( \"context\" \"log\" \"os\" \"time\" \"github.com/localrivet/gomcp/client\" ) func main() { log.SetOutput(os.Stderr) log.SetFlags(log.Ltime | log.Lshortfile) log.Println(\"Starting WebSocket Client...\") // Server's WebSocket URL (e.g., ws://localhost:8080/mcp) wsURL := \"ws://localhost:8080/mcp\" // Create a client instance for the WebSocket transport clt, err := client.NewWebSocketClient(\"MyWebSocketClient\", wsURL, client.ClientOptions{ // Optional configurations }) if err != nil { log.Fatalf(\"Failed to create WebSocket client: %v\", err) } defer clt.Close() ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second) defer cancel() // Connect to the server and perform the initialization handshake log.Println(\"Connecting to server via WebSocket...\") err = clt.Connect(ctx) if err != nil { log.Fatalf(\"Failed to connect and initialize: %v\", err) } log.Printf(\"Connected to server: %s\", clt.ServerInfo().Name) // Client is now ready to make requests using the 'clt' instance // ... example requests ... log.Println(\"Client operations finished.\") } WebSocket is generally preferred for new implementations supporting the latest protocol version due to its simplicity and efficiency for bidirectional communication.\nTCP Transport The TCP transport provides a lower-level option for raw TCP socket connections. This might be used in specific scenarios where a custom layer is built on top of TCP or for direct socket-based communication.\nTo create a client for this transport, use the client.NewTCPClient constructor:\npackage main import ( \"context\" \"log\" \"os\" \"time\" \"github.com/localrivet/gomcp/client\" ) func main() { log.SetOutput(os.Stderr) log.SetFlags(log.Ltime | log.Lshortfile) log.Println(\"Starting TCP Client...\") // Server's TCP address (e.g., localhost:6000) tcpAddr := \"localhost:6000\" // Create a client instance for the TCP transport clt, err := client.NewTCPClient(\"MyTCPClient\", tcpAddr, client.ClientOptions{ // Optional configurations }) if err != nil { log.Fatalf(\"Failed to create TCP client: %v\", err) } defer clt.Close() ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second) defer cancel() // Connect to the server and perform the initialization handshake log.Println(\"Connecting to server via TCP...\") err = clt.Connect(ctx) if err != nil { log.Fatalf(\"Failed to connect and initialize: %v\", err) } log.Printf(\"Connected to server: %s\", clt.ServerInfo().Name) // Client is now ready to make requests using the 'clt' instance // ... example requests ... log.Println(\"Client operations finished.\") } When using the TCP transport, you are responsible for ensuring that the data sent and received over the socket adheres to the JSON-RPC 2.0 and MCP specifications.\nClient Options (client.ClientOptions) All client transport constructors accept a client.ClientOptions struct for configuration:\ntype ClientOptions struct { // ClientCapabilities allows specifying the capabilities the client supports. // This is sent to the server during the initialization handshake. ClientCapabilities protocol.ClientCapabilities // Logger is an optional custom logger for client-side logging. Logger types.Logger // PreferredProtocolVersion allows the client to request a specific protocol version. // If nil, the client will attempt to negotiate the latest supported version. PreferredProtocolVersion *string // Custom options can be provided as key-value pairs for transport-specific settings. Custom map[string]interface{} } ClientCapabilities: Define the features your client supports. Logger: Provide a custom logger if you don’t want to use the default. PreferredProtocolVersion: Specify a desired protocol version. Custom: Pass transport-specific options. By choosing the appropriate transport and configuring the client options, you can build GoMCP clients that effectively communicate with various MCP servers.","message-structures#Message Structures":"Communication between an MCP client and server involves sending and receiving JSON-RPC messages. This section details the fundamental message structures used in MCP.\nJSON-RPC 2.0 Base Messages All messages exchanged in MCP adhere to the JSON-RPC 2.0 standard. The core message types are Request, Response, and Notification.\nRequest (protocol.JSONRPCRequest) A Request is sent by a client to a server (or vice-versa, though less common in the base protocol) to invoke a specific method. It expects a Response.\ntype JSONRPCRequest struct { JSONRPC string `json:\"jsonrpc\"` // MUST be \"2.0\" ID interface{} `json:\"id\"` // Request ID (string, number, or null) Method string `json:\"method\"` // Method name (e.g., \"initialize\", \"tools/call\") Params interface{} `json:\"params,omitempty\"` // Parameters (struct or array) } jsonrpc: Specifies the JSON-RPC version, must be \"2.0\". id: A unique identifier for the request. This can be a string, number, or null. The corresponding Response must use the same id. Notifications do not have an id. method: A string containing the name of the method to be invoked (e.g., \"initialize\", \"tools/call\", \"resources/get\"). params: An optional field containing the parameters for the method. This can be a structured object or an array of values, depending on the method definition. Response (protocol.JSONRPCResponse) A Response is sent by a server in reply to a Request. It contains either a result on success or an error on failure.\ntype JSONRPCResponse struct { JSONRPC string `json:\"jsonrpc\"` // MUST be \"2.0\" ID interface{} `json:\"id\"` // MUST be the same as the request ID (or null if error before ID parsing) Result interface{} `json:\"result,omitempty\"` // Result object (on success) Error *ErrorPayload `json:\"error,omitempty\"` // Error object (on failure) } jsonrpc: Specifies the JSON-RPC version, must be \"2.0\". id: The ID of the Request that this Response is replying to. If an error occurred before the server could parse the Request’s ID, this field may be null. result: This field is present on success and contains the data returned by the invoked method. Its structure depends on the method definition. error: This field is present on failure and contains an ErrorPayload object detailing the error. Notification (protocol.JSONRPCNotification) A Notification is sent by a client or server to signal an event or convey information. Unlike Requests, Notifications do not expect a Response.\ntype JSONRPCNotification struct { JSONRPC string `json:\"jsonrpc\"` // MUST be \"2.0\" Method string `json:\"method\"` // Method name (e.g., \"initialized\", \"notifications/...\") Params interface{} `json:\"params,omitempty\"` // Parameters (struct or array) // Note: Notifications MUST NOT have an 'id' field. } jsonrpc: Specifies the JSON-RPC version, must be \"2.0\". method: A string containing the name of the notification method (e.g., \"initialized\", \"$/cancelled\", \"notifications/resources/updated\"). params: An optional field containing parameters for the notification. Error Payload (protocol.ErrorPayload) When a JSON-RPC Request fails, the Response includes an error field containing an ErrorPayload object.\ntype ErrorPayload struct { Code int `json:\"code\"` // Numeric error code (JSON-RPC standard or implementation-defined) Message string `json:\"message\"` // Short error description Data interface{} `json:\"data,omitempty\"` // Optional additional error details } code: A numeric error code. JSON-RPC 2.0 defines a standard range of codes (e.g., -32700 to -32603 for parse errors, invalid requests, etc.). MCP may define additional implementation-specific codes. message: A concise, human-readable description of the error. data: An optional field that can contain additional structured data about the error. Content Structures (protocol.Content and Implementations) Many MCP messages, particularly tool results and prompt messages, include content. Content is represented as a slice of objects that implement the protocol.Content interface. This allows for rich, multi-part content.\ntype Content interface { GetType() string } The GetType() method returns a string indicating the specific type of content. GoMCP defines several standard content types:\nText Content (protocol.TextContent) Represents plain or formatted text.\ntype TextContent struct { Type string `json:\"type\"` // \"text\" Text string `json:\"text\"` Annotations *ContentAnnotations `json:\"annotations,omitempty\"` } type: Always \"text\". text: The string containing the text content. annotations: Optional metadata about the content (e.g., title, audience). Image Content (protocol.ImageContent) Represents image data, typically base64 encoded.\ntype ImageContent struct { Type string `json:\"type\"` // \"image\" Data string `json:\"data\"` // Base64 encoded image data MediaType string `json:\"mediaType\"` // e.g., \"image/png\", \"image/jpeg\" Annotations *ContentAnnotations `json:\"annotations,omitempty\"` } type: Always \"image\". data: The base64 encoded string of the image data. mediaType: The MIME type of the image (e.g., \"image/png\"). annotations: Optional metadata. Audio Content (protocol.AudioContent) Represents audio data, typically base64 encoded.\ntype AudioContent struct { Type string `json:\"type\"` // \"audio\" Data string `json:\"data\"` // Base64 encoded audio data MediaType string `json:\"mediaType\"` // e.g., \"audio/mpeg\", \"audio/wav\" Annotations *ContentAnnotations `json:\"annotations,omitempty\"` } type: Always \"audio\". data: The base64 encoded string of the audio data. mediaType: The MIME type of the audio (e.g., \"audio/mpeg\"). annotations: Optional metadata. Embedded Resource Content (protocol.EmbeddedResourceContent) Represents a reference to a resource that is embedded within the content.\ntype EmbeddedResourceContent struct { Type string `json:\"type\"` // \"resource\" Resource Resource `json:\"resource\"` // The protocol.Resource struct Annotations *ContentAnnotations `json:\"annotations,omitempty\"` } type: Always \"resource\". resource: The protocol.Resource struct defining the embedded resource. annotations: Optional metadata. Content Annotations (protocol.ContentAnnotations) Optional metadata that can be applied to individual content parts.\ntype ContentAnnotations struct { Title *string `json:\"title,omitempty\"` Audience []string `json:\"audience,omitempty\"` Priority *float64 `json:\"priority,omitempty\"` // 0-1, higher is more important } title: An optional title for the content part. audience: An optional list of strings indicating the intended audience for this content part (e.g., [\"user\"], [\"model\"]). priority: An optional floating-point number between 0 and 1 indicating the importance of this content part, where a higher value means higher priority. "},"title":"Clients"},"/clients/transports/":{"data":{"":"","transports#Transports":"GoMCP separates the core protocol logic from how clients and servers communicate. Supported transports are found in the transport/ directory. The gomcp/client package provides constructors for the supported transports, abstracting away the low-level communication details.\nChoosing a Transport Select the transport that corresponds to the server you are connecting to:\nStdio: For communicating with a server running as a local child process, piping standard input/output. SSE + HTTP: For connecting to servers implementing the 2024-11-05 protocol’s HTTP+SSE transport model (HTTP POST for requests, SSE for server-to-client messages). WebSocket: For connecting to servers implementing the 2025-03-26 protocol’s Streamable HTTP transport model (single WebSocket connection for all messages). TCP: A lower-level option for raw TCP socket communication. Stdio Transport The Stdio transport facilitates communication over standard input and output streams. This is particularly useful for:\nLocal Inter-Process Communication: When your client application launches and manages the server as a child process. Simple Examples and Testing: Provides an easy way to demonstrate basic MCP communication without network setup. To create a client using the Stdio transport, use the client.NewStdioClient constructor:\npackage main import ( \"context\" \"log\" \"os\" \"time\" \"github.com/localrivet/gomcp/client\" ) func main() { log.SetOutput(os.Stderr) log.SetFlags(log.Ltime | log.Lshortfile) log.Println(\"Starting Stdio Client...\") // Create a client instance for the stdio transport // Provide a client name and optional ClientOptions clt, err := client.NewStdioClient(\"MyStdioClient\", client.ClientOptions{ // Optional configurations can go here // Logger: myCustomLogger, }) if err != nil { log.Fatalf(\"Failed to create stdio client: %v\", err) } // Ensure the client connection is closed when main exits defer clt.Close() ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second) defer cancel() // Connect to the server and perform the initialization handshake log.Println(\"Connecting to server via stdio...\") err = clt.Connect(ctx) if err != nil { log.Fatalf(\"Failed to connect and initialize: %v\", err) } log.Printf(\"Connected to server: %s\", clt.ServerInfo().Name) // Client is now ready to make requests using the 'clt' instance // ... example requests like ListTools, CallTool, etc. ... log.Println(\"Client operations finished.\") } When using Stdio, the client typically writes JSON-RPC messages to standard output, which are read by the server from its standard input, and vice-versa.\nSSE + HTTP Hybrid Transport This transport is designed for network communication and is compatible with servers implementing the transport model introduced in the 2024-11-05 protocol specification. It utilizes:\nHTTP POST: For the client to send requests (like initialize, tools/call). Server-Sent Events (SSE): For the server to send asynchronous messages (like initialize responses, notifications, server-initiated requests) to the client over a persistent connection. To create a client for this transport, use the client.NewSSEClient constructor:\npackage main import ( \"context\" \"log\" \"os\" \"time\" \"github.com/localrivet/gomcp/client\" ) func main() { log.SetOutput(os.Stderr) log.SetFlags(log.Ltime | log.Lshortfile) log.Println(\"Starting SSE Client...\") // Server's base URL (e.g., http://localhost:8080) baseURL := \"http://localhost:8080\" // The base path for MCP endpoints on the server (e.g., /mcp) basePath := \"/mcp\" // Create a client instance for the SSE transport clt, err := client.NewSSEClient(\"MySSEClient\", baseURL, basePath, client.ClientOptions{ // Optional configurations }) if err != nil { log.Fatalf(\"Failed to create SSE client: %v\", err) } defer clt.Close() ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second) defer cancel() // Connect to the server and perform the initialization handshake log.Println(\"Connecting to server via SSE+HTTP...\") err = clt.Connect(ctx) if err != nil { log.Fatalf(\"Failed to connect and initialize: %v\", err) } log.Printf(\"Connected to server: %s\", clt.ServerInfo().Name) // Client is now ready to make requests using the 'clt' instance // ... example requests ... log.Println(\"Client operations finished.\") } This transport is suitable for web-based clients or environments where SSE is a preferred mechanism for server-push.\nWebSocket Transport The WebSocket transport is the recommended network transport for servers implementing the 2025-03-26 protocol specification’s “Streamable HTTP” model. It uses a single, full-duplex WebSocket connection for all communication, allowing both client and server to send messages asynchronously over the same connection.\nTo create a client for this transport, use the client.NewWebSocketClient constructor:\npackage main import ( \"context\" \"log\" \"os\" \"time\" \"github.com/localrivet/gomcp/client\" ) func main() { log.SetOutput(os.Stderr) log.SetFlags(log.Ltime | log.Lshortfile) log.Println(\"Starting WebSocket Client...\") // Server's WebSocket URL (e.g., ws://localhost:8080/mcp) wsURL := \"ws://localhost:8080/mcp\" // Create a client instance for the WebSocket transport clt, err := client.NewWebSocketClient(\"MyWebSocketClient\", wsURL, client.ClientOptions{ // Optional configurations }) if err != nil { log.Fatalf(\"Failed to create WebSocket client: %v\", err) } defer clt.Close() ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second) defer cancel() // Connect to the server and perform the initialization handshake log.Println(\"Connecting to server via WebSocket...\") err = clt.Connect(ctx) if err != nil { log.Fatalf(\"Failed to connect and initialize: %v\", err) } log.Printf(\"Connected to server: %s\", clt.ServerInfo().Name) // Client is now ready to make requests using the 'clt' instance // ... example requests ... log.Println(\"Client operations finished.\") } WebSocket is generally preferred for new implementations supporting the latest protocol version due to its simplicity and efficiency for bidirectional communication.\nTCP Transport The TCP transport provides a lower-level option for raw TCP socket connections. This might be used in specific scenarios where a custom layer is built on top of TCP or for direct socket-based communication.\nTo create a client for this transport, use the client.NewTCPClient constructor:\npackage main import ( \"context\" \"log\" \"os\" \"time\" \"github.com/localrivet/gomcp/client\" ) func main() { log.SetOutput(os.Stderr) log.SetFlags(log.Ltime | log.Lshortfile) log.Println(\"Starting TCP Client...\") // Server's TCP address (e.g., localhost:6000) tcpAddr := \"localhost:6000\" // Create a client instance for the TCP transport clt, err := client.NewTCPClient(\"MyTCPClient\", tcpAddr, client.ClientOptions{ // Optional configurations }) if err != nil { log.Fatalf(\"Failed to create TCP client: %v\", err) } defer clt.Close() ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second) defer cancel() // Connect to the server and perform the initialization handshake log.Println(\"Connecting to server via TCP...\") err = clt.Connect(ctx) if err != nil { log.Fatalf(\"Failed to connect and initialize: %v\", err) } log.Printf(\"Connected to server: %s\", clt.ServerInfo().Name) // Client is now ready to make requests using the 'clt' instance // ... example requests ... log.Println(\"Client operations finished.\") } When using the TCP transport, you are responsible for ensuring that the data sent and received over the socket adheres to the JSON-RPC 2.0 and MCP specifications.\nClient Options (client.ClientOptions) All client transport constructors accept a client.ClientOptions struct for configuration:\ntype ClientOptions struct { // ClientCapabilities allows specifying the capabilities the client supports. // This is sent to the server during the initialization handshake. ClientCapabilities protocol.ClientCapabilities Logger types.Logger // PreferredProtocolVersion allows the client to request a specific protocol version. // If nil, the client will attempt to negotiate the latest supported version. PreferredProtocolVersion *string // Custom options can be provided as key-value pairs for transport-specific settings. Custom map[string]interface{} } ClientCapabilities: Define the features your client supports. Logger: Provide a custom logger if you don’t want to use the default. PreferredProtocolVersion: Specify a desired protocol version. Custom: Pass transport-specific options. By choosing the appropriate transport and configuring the client options, you can build GoMCP clients that effectively communicate with various MCP servers."},"title":"Transports"},"/contributing/":{"data":{"contributing-to-gomcp#Contributing to GoMCP":"Contributing to GoMCPThank you for your interest in contributing to GoMCP!","development#Development":" Clone the repository: git clone git@github.com:localrivet/gomcp.git Navigate to the directory: cd gomcp Make your changes. Run tests: go test ./... Format code: gofmt -w . Commit your changes and open a pull request. ","how-to-contribute#How to Contribute":" Reporting Issues: If you find a bug or have a feature request, please open an issue on the GitHub repository issues page. Pull Requests: Pull requests are welcome! Please ensure your code adheres to standard Go formatting (gofmt) and includes relevant tests. It’s often best to open an issue first to discuss significant changes. "},"title":"Contributing"},"/deployment/":{"data":{"":"","deployment#Deployment":"Content for the Deployment section goes here."},"title":"Deployment"},"/examples/":{"data":{"":"The [github.com/localrivet/gomcp/examples] directory contains various client/server pairs demonstrating specific features, transports, and integrations:\nBasic Usage: basic/: Simple stdio communication with multiple tools. hello-demo/: Minimal example showcasing tool, prompt, and resource registration (stdio). client_helpers_demo/: Demonstrates client-side helpers for configuration loading and tool calls. Network Transports: http/: Integration with various Go HTTP frameworks using the Streamable HTTP (SSE) transport (includes Gin, Echo, Chi, Fiber, etc.). websocket/: Demonstrates the WebSocket transport. Configuration \u0026 Deployment: configuration/: Loading server configuration from files (JSON, YAML, TOML). cmd/: Generic command-line client and server implementations configurable for different transports. Advanced Features: auth/: Simple API key authentication hook example (stdio). rate-limit/: Example of rate limiting client requests (stdio). kitchen-sink/: Comprehensive server example combining multiple features (stdio). code-assistant/: Example server providing code review/documentation tools. meta-tool-demo/: Server demonstrating a tool that calls other tools. Running Examples:\nNavigate to an example’s server directory (e.g., cd examples/websocket/server). Run the server: go run . In another terminal, navigate to the corresponding client directory (e.g., cd examples/websocket/client). Run the client: go run . (Check the specific README within each example directory for more detailed instructions if available.)"},"title":"Examples"},"/get-started/":{"data":{"":"","#":"This guide will walk you through how to add the gomcp library to your Go project.\nPrerequisites Before you begin, ensure you have the following installed:\nGo: You need a recent version of Go installed on your system. Go version 1.18 or later is recommended as it includes support for generics, which are used in some parts of the gomcp library. You can download and install Go from the official Go website: https://golang.org/dl/ A Go Project: You should have an existing Go project or create a new one. If you’re creating a new project, initialize a Go module: go mod init your_module_name Installing GoMCP To add the gomcp library to your Go project, open your terminal or command prompt, navigate to your project’s root directory, and run the following command:\ngo get github.com/localrivet/gomcp This command will download the gomcp library and its dependencies and add them to your project’s go.mod file.\nImporting the Library Once installed, you can import the necessary packages in your Go code to start building MCP servers or clients:\nimport ( \"github.com/localrivet/gomcp/client\" // For building MCP clients \"github.com/localrivet/gomcp/server\" // For building MCP servers \"github.com/localrivet/gomcp/protocol\" // For MCP message types and structures // You may also need to import specific transport packages, e.g.: // \"github.com/localrivet/gomcp/transport/stdio\" // \"github.com/localrivet/gomcp/transport/sse\" // \"github.com/localrivet/gomcp/transport/websocket\" ) "},"title":"Installation"},"/get-started/installation/":{"data":{"":"","#":"Prerequisites Before you begin, ensure you have the following installed:\nGo: You need a recent version of Go installed on your system. Go version 1.18 or later is recommended as it includes support for generics, which are used in some parts of the gomcp library. You can download and install Go from the official Go website: https://golang.org/dl/ A Go Project: You should have an existing Go project or create a new one. If you’re creating a new project, initialize a Go module: go mod init your_module_name Installing GoMCP To add the gomcp library to your Go project, open your terminal or command prompt, navigate to your project’s root directory, and run the following command:\ngo get github.com/localrivet/gomcp This command will download the gomcp library and its dependencies and add them to your project’s go.mod file.\nImporting the Library Once installed, you can import the necessary packages in your Go code to start building MCP servers or clients:\nimport ( \"github.com/localrivet/gomcp/client\" // For building MCP clients \"github.com/localrivet/gomcp/server\" // For building MCP servers \"github.com/localrivet/gomcp/protocol\" // For MCP message types and structures // You may also need to import specific transport packages, e.g.: // \"github.com/localrivet/gomcp/transport/stdio\" // \"github.com/localrivet/gomcp/transport/sse\" // \"github.com/localrivet/gomcp/transport/websocket\" ) ","quickstart#Quickstart":"This guide provides a quick introduction to building a minimal GoMCP server and client that communicate using the standard input/output (stdio) transport. This will give you a basic understanding of how to get started with the library.\nYour First MCP Server Let’s create a simple MCP server that registers a basic “echo” tool. This tool will simply return the input text it receives.\nCreate a new file (e.g., server/main.go) and add the following code:\npackage main import ( \"context\" \"fmt\" \"log\" \"os\" \"github.com/localrivet/gomcp/protocol\" \"github.com/localrivet/gomcp/server\" \"github.com/localrivet/gomcp/util/schema\" // Helper for argument schema ) // Define the arguments the echo tool expects type EchoArgs struct { Input string `json:\"input\" description:\"Text to echo back\"` } // Define the handler function for the echo tool func handleEchoTool(ctx context.Context, progressToken *protocol.ProgressToken, arguments any) (content []protocol.Content, isError bool) { // Use the schema helper to parse and validate arguments args, errContent, isErr := schema.HandleArgs[EchoArgs](arguments) if isErr { // Return the error content generated by HandleArgs return errContent, true } // Log the tool execution (optional) log.Printf(\"Echo tool received input: %s\", args.Input) // Prepare the result content resultContent := []protocol.Content{ protocol.TextContent{ Type: \"text\", Text: \"Echo: \" + args.Input, }, } // Return the result and indicate no error return resultContent, false } func main() { // Configure logger (optional, defaults to stderr) log.SetOutput(os.Stderr) log.SetFlags(log.Ltime | log.Lshortfile) log.Println(\"Starting Minimal MCP Server...\") // Create the core server instance // Provide a name and default options srv := server.NewServer(\"MyMinimalEchoServer\", server.ServerOptions{}) // Define the metadata for the echo tool echoTool := protocol.Tool{ Name: \"echo\", Description: \"Echoes back the input text.\", InputSchema: schema.FromStruct(EchoArgs{}), // Generate schema from the struct } // Register the echo tool with its handler function err := srv.RegisterTool(echoTool, handleEchoTool) if err != nil { log.Fatalf(\"Failed to register tool: %v\", err) } log.Printf(\"Registered tool: %s\", echoTool.Name) // Start the server using the built-in stdio handler. // This blocks until the server exits (e.g., EOF on stdin or error). log.Println(\"Server setup complete. Listening on stdio...\") if err := server.ServeStdio(srv); err != nil { log.Fatalf(\"Server exited with error: %v\", err) } log.Println(\"Server shutdown complete.\") } Your First MCP Client Now, let’s create a simple MCP client that connects to our server via stdio, lists the available tools, and calls the “echo” tool.\nCreate a new file (e.g., client/main.go) and add the following code:\npackage main import ( \"context\" \"log\" \"os\" \"time\" \"github.com/localrivet/gomcp/client\" \"github.com/localrivet/gomcp/protocol\" ) func main() { // Configure logger (optional) log.SetOutput(os.Stderr) log.SetFlags(log.Ltime | log.Lshortfile) log.Println(\"Starting Simple Stdio MCP Client...\") // Create a client instance for the stdio transport // NewStdioClient handles the underlying transport setup clt, err := client.NewStdioClient(\"MyMinimalEchoClient\", client.ClientOptions{}) if err != nil { log.Fatalf(\"Failed to create stdio client: %v\", err) } // Ensure the client connection is closed when main exits defer clt.Close() // Use a context for the connection and requests ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second) defer cancel() // Connect to the server and perform the initialization handshake log.Println(\"Connecting to server via stdio...\") err = clt.Connect(ctx) if err != nil { log.Fatalf(\"Failed to connect and initialize with server: %v\", err) } log.Printf(\"Connected to server: %s (Version: %s)\", clt.ServerInfo().Name, clt.ServerInfo().Version) // --- Client is now ready to make requests --- // Example: List available tools from the server log.Println(\"Listing available tools...\") toolsResult, err := clt.ListTools(ctx, protocol.ListToolsRequestParams{}) if err != nil { log.Printf(\"Error listing tools: %v\", err) } else { log.Printf(\"Available tools (%d):\", len(toolsResult.Tools)) for _, tool := range toolsResult.Tools { log.Printf(\"- %s: %s\", tool.Name, tool.Description) } } // Example: Call the \"echo\" tool log.Println(\"Calling 'echo' tool...\") callToolParams := protocol.CallToolParams{ Name: \"echo\", Arguments: map[string]interface{}{ \"input\": \"Hello from the client!\", }, } callToolResult, err := clt.CallTool(ctx, callToolParams) if err != nil { log.Printf(\"Error calling tool 'echo': %v\", err) } else { log.Println(\"Tool 'echo' returned content:\") for _, content := range callToolResult.Content { // Assuming TextContent for this example if textContent, ok := content.(protocol.TextContent); ok { log.Printf(\"- %s: %s\", textContent.Type, textContent.Text) } else { log.Printf(\"- Received content of type: %s\", content.GetContentType()) } } if callToolResult.IsError != nil \u0026\u0026 *callToolResult.IsError { log.Println(\"Tool execution reported an error.\") } } log.Println(\"Client operations finished.\") } Running the Example To run this minimal server and client and see them communicate:\nSave the server code as server/main.go and the client code as client/main.go within your Go project. Navigate to your project’s root directory in your terminal. Run go mod tidy to ensure dependencies are fetched. Pipe the output of the client directly into the input of the server: go run client/main.go | go run server/main.go You should see output from both the client and the server demonstrating the MCP handshake, tool listing, and the echo tool call. Next Steps You have successfully built and run a minimal GoMCP server and client. To learn more, explore the detailed guides:\nServers: Learn how to build more complex MCP servers with various capabilities. Clients: Understand how to build clients that interact with servers using different transports and features. "},"title":"Get Started"},"/get-started/quickstart/":{"data":{"":"Let’s create a simple MCP server that exposes a calculator tool and a client that uses it, communicating over stdio.\nServer (calculator_server/main.go)\npackage main import ( \"fmt\" \"log\" \"os\" \"strconv\" \"github.com/localrivet/gomcp/protocol\" \"github.com/localrivet/gomcp/server\" ) // Arguments for the 'add' tool type AddArgs struct { A float64 `json:\"a\" description:\"First number\" required:\"true\"` B float64 `json:\"b\" description:\"Second number\" required:\"true\"` } func main() { log.SetOutput(os.Stderr) log.SetFlags(log.Ltime | log.Lmsgprefix) log.SetPrefix(\"[CalcServer] \") log.Println(\"Starting Calculator MCP Server (Stdio)...\") // Create the MCP server instance srv := server.NewServer(\"calculator-stdio\") // Add the 'add' tool using the server.AddTool helper // The helper infers the schema from the handler's argument type (AddArgs) err := server.AddTool( srv, \"add\", \"Add two numbers.\", // Handler function using the args struct func(args AddArgs) (protocol.Content, error) { result := args.A + args.B log.Printf(\"[add tool] %f + %f -\u003e %f\", args.A, args.B, result) // Use server.Text helper for simple text responses return server.Text(strconv.FormatFloat(result, 'f', -1, 64)), nil }, ) if err != nil { log.Fatalf(\"Failed to add 'add' tool: %v\", err) } // Start the server using the built-in stdio handler. // This blocks until the server exits (e.g., stdin is closed). log.Println(\"Server setup complete. Listening on stdio...\") if err := server.ServeStdio(srv); err != nil { log.Fatalf(\"Server exited with error: %v\", err) } log.Println(\"Server shutdown complete.\") } Client (calculator_client/main.go)\npackage main import ( \"context\" \"log\" \"os\" \"time\" \"github.com/localrivet/gomcp/client\" \"github.com/localrivet/gomcp/protocol\" ) func main() { log.SetOutput(os.Stderr) log.SetFlags(log.Ltime | log.Lmsgprefix) log.SetPrefix(\"[CalcClient] \") log.Println(\"Starting Calculator MCP Client (Stdio)...\") // Create a client configured for stdio communication // Point it to the server executable (adjust path as needed) // For simple Go examples, you might run the server first and then the client. // If running separately, use the actual command to start the server: // cmd := []string{\"go\", \"run\", \"../calculator_server/main.go\"} // clt, err := client.NewStdioClientWithCommand(\"MyCalcClient\", client.ClientOptions{}, cmd) // For simplicity here, assume server is already running and connected to stdin/stdout clt, err := client.NewStdioClient(\"MyCalcClient\", client.ClientOptions{}) if err != nil { log.Fatalf(\"Failed to create client: %v\", err) } // Set a timeout for the connection and operations ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second) defer cancel() // Connect and perform initialization handshake log.Println(\"Connecting to server via stdio...\") if err = clt.Connect(ctx); err != nil { log.Fatalf(\"Client failed to connect: %v\", err) } defer clt.Close() // Ensure connection resources are cleaned up serverInfo := clt.ServerInfo() log.Printf(\"Connected to server: %s (Version: %s)\", serverInfo.Name, serverInfo.Version) // Call the 'add' tool log.Println(\"--- Calling 'add' Tool ---\") addArgs := map[string]interface{}{\"a\": 15.5, \"b\": 4.5} callParams := protocol.CallToolParams{Name: \"add\", Arguments: addArgs} callCtx, callCancel := context.WithTimeout(context.Background(), 5*time.Second) defer callCancel() callResult, err := clt.CallTool(callCtx, callParams, nil) // No progress token needed if err != nil { log.Printf(\"Error calling tool 'add': %v\", err) } else if callResult.IsError { log.Printf(\"Tool 'add' call returned an error:\") for _, content := range callResult.Content { if textContent, ok := content.(protocol.TextContent); ok { log.Printf(\" Error Content: %s\", textContent.Text) } } } else { log.Printf(\"Tool 'add' call successful:\") for _, content := range callResult.Content { if textContent, ok := content.(protocol.TextContent); ok { log.Printf(\" Result: %s\", textContent.Text) // Expecting \"20\" } } } log.Println(\"Client finished.\") } Running the Quickstart:\nSave the server code as calculator_server/main.go. Save the client code as calculator_client/main.go. Compile and run the server: go run calculator_server/main.go In another terminal, compile and run the client: go run calculator_client/main.go The client will connect to the server via stdio, call the add tool, print the result, and exit."},"title":"Quickstart"},"/patterns/":{"data":{"":"","patterns#Patterns":"This section describes common patterns for building and using MCP servers and clients."},"title":"Patterns"},"/patterns/composition/":{"data":{"":"","composition#Composition":"Content for the Composition section goes here."},"title":"Composition"},"/patterns/contrib/":{"data":{"":"","contrib-modules#Contrib Modules":"Content for the Contrib Modules section goes here."},"title":"Contrib Modules"},"/patterns/decorating-methods/":{"data":{"":"","decorating-methods#Decorating Methods":"Content for the Decorating Methods section goes here."},"title":"Decorating Methods"},"/patterns/fastapi/":{"data":{"":"","fastapi#FastAPI":"Content for the FastAPI section goes here."},"title":"FastAPI"},"/patterns/fluent-interface/":{"data":{"benefits#Benefits":" Improved readability: Configuration code becomes more declarative and easier to understand Reduced boilerplate: Less repetition of object references Contextual methods: Methods are only available in appropriate contexts Natural API discovery: Code editors can suggest the next appropriate methods in the chain ","complete-example#Complete Example":"Here’s a complete example showing the fluent interface pattern in action:\npackage main import ( \"github.com/localrivet/gomcp/server\" ) func main() { // Create and configure the server with fluent interface server.NewServer(\"demo-server\"). // Register tools Tool(\"greet\", \"Greet a user\", func(ctx *server.Context, args struct { Name string `json:\"name\" description:\"User name\"` }) (string, error) { return \"Hello, \" + args.Name + \"!\", nil }). Tool(\"sum\", \"Sum two numbers\", func(ctx *server.Context, args struct { A int `json:\"a\" description:\"First number\"` B int `json:\"b\" description:\"Second number\"` }) (int, error) { return args.A + args.B, nil }). // Register resources Resource(\"app://info/version\", server.WithTextContent(\"1.0.0\"), server.WithDescription(\"Application version\")). Resource(\"app://status\", server.WithJSONContent(map[string]interface{}{ \"status\": \"healthy\", \"uptime\": \"12h\", })). // Configure and start with WebSocket transport AsWebsocket(\":9090\", \"/mcp\"). Run() } ","error-handling#Error Handling":"While the fluent interface pattern provides a cleaner API, it does require careful error handling. In GoMCP:\nMost configuration errors are logged but don’t break the chain Fatal errors during server startup are returned from the Run() method For more granular error handling, you can use the traditional non-fluent API alongside the fluent one ","fluent-interface-pattern-in-gomcp#Fluent Interface Pattern in GoMCP":"Fluent Interface Pattern in GoMCPGoMCP implements a fluent interface pattern (also known as method chaining) to provide a clean, readable API for configuring servers, registering tools and resources, and setting up transports.","key-pattern-components#Key Pattern Components":"1. Server Creation and Configuration The fluent interface starts with creating a new server:\nsrv := server.NewServer(\"my-server\") 2. Tool Registration Register tools by chaining the Tool method:\nsrv.Tool(\"tool-name\", \"Tool description\", func(ctx *server.Context, args SomeArgsStruct) (interface{}, error) { // Tool implementation return result, nil }) 3. Resource Registration Register resources with the Resource method and functional options:\nsrv.Resource(\"resource://uri\", server.WithTextContent(\"Some content\"), server.WithDescription(\"Resource description\")) 4. Transport Configuration Configure the transport method:\n// WebSocket srv.AsWebsocket(\":9090\", \"/mcp\") // SSE srv.AsSSE(\":9090\", \"/mcp\") // Stdio srv.AsStdio() // TCP srv.AsTCP(\":9090\") 5. Server Start Finally, start the server:\nsrv.Run() ","migration-from-pre-fluent-api#Migration from Pre-Fluent API":"If you’re upgrading from an older version of GoMCP, here’s a guide to migrate from the traditional API to the fluent interface:\nTraditional API Fluent Interface server.AddTool(srv, name, desc, handler) srv.Tool(name, desc, handler) srv.AddResource(resourceDef) srv.Resource(uri, options...) server.ServeWebsocket(srv, addr, path) srv.AsWebsocket(addr, path).Run() server.ServeSSE(srv, addr, path) srv.AsSSE(addr, path).Run() server.ServeStdio(srv) srv.AsStdio().Run() server.ServeTCP(srv, addr) srv.AsTCP(addr).Run() ","server-configuration-example#Server Configuration Example":"Here’s an example of the fluent interface pattern in GoMCP for configuring a server:\n// Traditional approach (pre-fluent interface) srv := server.NewServer(\"my-server\") server.AddTool(srv, \"echo\", \"Echo a message\", handleEchoTool) err := srv.AddResource(protocol.ResourceDefinition{...}) if err != nil { // Handle error } // Configure and start the server err = server.ServeWebsocket(srv, \":9090\", \"/mcp\") if err != nil { // Handle error } // Fluent interface approach srv := server.NewServer(\"my-server\"). Tool(\"echo\", \"Echo a message\", handleEchoTool). Resource(\"app://info/version\", server.WithTextContent(\"1.0.0\")). AsWebsocket(\":9090\", \"/mcp\"). Run() ","what-is-a-fluent-interface#What is a Fluent Interface?":"A fluent interface is a method of designing object-oriented APIs where multiple method calls can be chained together in a single statement. Each method returns the object itself (or another appropriate object), allowing further method calls on the same statement.\nIn GoMCP, this pattern is used extensively to make the server configuration more concise and expressive.","when-to-use#When to Use":"The fluent interface pattern is ideal for:\nInitial server setup and configuration Registering multiple tools and resources Creating simple, concise examples For more complex scenarios where detailed error handling is required, you might mix the fluent interface with traditional approaches."},"title":"Fluent Interface Pattern"},"/patterns/openapi/":{"data":{"":"","openapi#OpenAPI":"Content for the OpenAPI section goes here."},"title":"OpenAPI"},"/patterns/proxy/":{"data":{"":"","proxying#Proxying":"Content for the Proxying section goes here."},"title":"Proxying"},"/patterns/testing/":{"data":{"":"","testing#Testing":"Content for the Testing section goes here."},"title":"Testing"},"/servers/":{"data":{"":"","#":"","handling-client-messages#Handling Client Messages":"The server.Server automatically handles incoming JSON-RPC requests and notifications based on the registered capabilities and standard protocol methods (like initialize, tools/call, resources/get, $/cancelled). You generally don’t need to handle raw messages directly unless implementing custom notifications or requests.","initializing-the-server-server-package#Initializing the Server (\u003ccode\u003eserver\u003c/code\u003e package)":"The gomcp library provides the core logic for building mcp servers. The main server logic resides in the server package, which is designed to be transport-agnostic. This means the core server doesn’t care how messages are sent or received; that’s handled by a separate Transport implementation.\nThe server.Server and client.Client server.Server: The central object for your MCP server application. You register tools, resources, and prompts with it. client.Client: Represents a connection to an MCP server, allowing you to interact with its capabilities. // Server Initialization srv := server.NewServer(\"my-awesome-server\") // Client Initialization (Stdio example) clt, err := client.NewStdioClient(\"my-cool-client\", client.ClientOptions{}) if err != nil { /* handle error */ } Server Role An MCP server built with gomcp typically performs the following functions:\nListens for Connections: Accepts incoming client connections via a specific transport mechanism (e.g., Stdio, SSE+HTTP, WebSockets). Handles Initialization: Manages the MCP initialization handshake (initialize request and initialized notification) with connecting clients to exchange capabilities and establish a session. Exposes Capabilities: Advertises its supported features and the capabilities it provides (tools, resources, prompts) to connected clients. Registers Offerings: Allows you to register the specific tools, resources, and prompts that your server makes available. Handles Client Requests: Processes incoming JSON-RPC requests from clients (e.g., tools/call, resources/get, prompts/list) and sends back appropriate responses or errors. Handles Client Notifications: Processes incoming JSON-RPC notifications from clients (e.g., $/cancelled, initialized). Sends Server Messages: Can send server-initiated notifications to clients (e.g., $/progress, notifications/message, notifications/resources/updated) to provide updates or information. Initializing the Server (server package) The server.Server struct holds the state and core logic for your MCP server instance. You create a new server using the server.NewServer constructor, providing a server name and optional configuration options.\npackage main import ( \"log\" \"os\" \"github.com/localrivet/gomcp/server\" // Import necessary transport package(s) \"github.com/localrivet/gomcp/transport/stdio\" ) func main() { // Configure logger (optional, defaults to stderr) log.SetOutput(os.Stderr) log.SetFlags(log.Ltime | log.Lshortfile) log.Println(\"Starting My MCP Server...\") // 1. Create the Server Instance // Provide a unique name for your server and optional server options. srv := server.NewServer(\"my-gomcp-server\", server.ServerOptions{ // Optional: Configure server capabilities if needed (defaults are reasonable) // ServerCapabilities: protocol.ServerCapabilities{ // Tools: \u0026protocol.ToolsCaps{ListChanged: true}, // Example: Indicate support for tools list changes // }, // Optional: Provide a custom logger // Logger: myCustomLogger, // Optional: Set server instructions (sent to client during initialization) // Instructions: \"This server provides tools for data analysis.\", }) // 2. Define and Register Capabilities (Tools, Resources, Prompts) // This is where you define and register the specific functionalities // your server offers. See the dedicated guides for each type: // - [Tools](https://gomcp.dev/servers/defining-tools/) // - [Resources](https://gomcp.dev/servers/resources/) // - [Prompts](https://gomcp.dev/servers/prompts/) // Example: Register a simple tool (details in the Tools guide) // srv.RegisterTool(...) // 3. Run the Server using a built-in transport handler // Choose the appropriate ServeX function based on your desired transport. log.Println(\"Server setup complete. Starting server...\") if err := server.ServeStdio(srv); err != nil { // Example using Stdio transport // ServeStdio blocks until the transport is closed or an error occurs log.Fatalf(\"Server exited with error: %v\", err) } log.Println(\"Server stopped.\") } The server.ServerOptions struct allows you to customize the server’s behavior:\nServerCapabilities (protocol.ServerCapabilities): Define the features your server supports. Logger (types.Logger): Provide a custom logger implementation. Instructions (string): A string containing instructions or a brief description of the server, sent to the client during initialization. ","registering-capabilities#Registering Capabilities":"Before running the server, you need to register the specific tools, resources, and prompts that your server will expose to clients. The server.Server provides methods for this:\nRegisterTool(tool protocol.Tool, handler hooks.FinalToolHandler): Registers a tool definition and the handler function that will be executed when a client calls the tool. See the Tools guide for details. RegisterResource(resource protocol.Resource): Registers a resource definition. See the Resources guide for details on defining and providing resource content. RegisterPrompt(prompt protocol.Prompt): Registers a prompt template definition. See the Prompts guide for details. ","running-the-server#Running the Server":"After creating the server instance and registering its capabilities, you need to start it using a transport handler. The server package provides convenience functions for common transports:\nserver.ServeStdio(srv *Server): Runs the server using Standard Input/Output. server.ServeSSE(srv *Server, addr string, basePath string): Runs the server using the HTTP+SSE transport. server.ServeWebSocket(srv *Server, addr string, path string): Runs the server using the WebSocket transport. server.ServeTCP(srv *Server, addr string): Runs the server using a raw TCP socket connection. Choose the appropriate ServeX function based on how you want your server to communicate. These functions typically block, running the server’s main loop until the transport is closed or an error occurs.\nAlternatively, for more control, you can implement the types.Transport interface yourself and use the srv.Run(transport types.Transport) method.","sending-server-messages#Sending Server Messages":"Your server application can send notifications or requests to connected clients. This is usually done via the types.ClientSession interface, which is managed internally by the server and implemented by the transport layer. Methods like session.SendNotification and session.SendResponse (accessible via the ClientSession object passed to handlers or retrieved from the server’s session management) facilitate this. The server.Server also provides convenience methods like srv.SendProgress and srv.NotifyResourceUpdated for common notifications. See the Context guide for more on accessing session context and sending messages.","server-role#Server Role":""},"title":"Servers"},"/servers/context/":{"data":{"":"","accessing-client-session-information#Accessing Client Session Information":"","cancellation-cancelled#Cancellation (\u003ccode\u003e$/cancelled\u003c/code\u003e)":"When implementing handlers for tools, resources, or notifications in your GoMCP server, you often need access to contextual information about the client session making the request, the server itself, or the request’s lifecycle (like cancellation). The GoMCP library provides this context primarily through the standard context.Context object and the types.ClientSession interface passed to your handlers.\nAccessing Client Session Information Handlers for requests and notifications receive a context.Context and, for most request types, a types.ClientSession object. The types.ClientSession interface represents the active connection from a single client and provides methods to interact with that specific client and retrieve session-specific details.\npackage main import ( \"context\" \"log\" \"github.com/localrivet/gomcp/protocol\" \"github.com/localrivet/gomcp/server\" \"github.com/localrivet/gomcp/types\" // Import the types package ) // Example Tool Handler demonstrating access to ClientSession func handleMyTool(ctx context.Context, progressToken *protocol.ProgressToken, arguments any) (content []protocol.Content, isError bool) { // Access the ClientSession from the context // The server automatically adds the session to the context for request handlers. session, ok := types.SessionFromContext(ctx) if !ok { // This check is a safeguard; in standard request handlers, the session should be present. log.Println(\"Error: ClientSession not found in context.\") return []protocol.Content{protocol.TextContent{Type: \"text\", Text: \"Internal server error: Session context missing.\"}}, true } // Get session ID sessionID := session.SessionID() log.Printf(\"Tool 'myTool' called by session: %s\", sessionID) // Get client capabilities advertised during initialization clientCaps := session.GetClientCapabilities() log.Printf(\"Client capabilities for session %s: %+v\", sessionID, clientCaps) // Get the negotiated protocol version for this session negotiatedVersion := session.GetNegotiatedVersion() log.Printf(\"Negotiated protocol version for session %s: %s\", sessionID, negotiatedVersion) // You can use the session object to send messages back to this specific client // For example, sending a custom notification: // customNotificationParams := map[string]string{\"status\": \"processing\"} // notification := protocol.JSONRPCNotification{Method: \"myServer/statusUpdate\", Params: customNotificationParams} // if err := session.SendNotification(notification); err != nil { // log.Printf(\"Failed to send status update notification to session %s: %v\", sessionID, err) // } // ... rest of your tool handler logic ... return []protocol.Content{protocol.TextContent{Type: \"text\", Text: \"Tool executed successfully.\"}}, false } The types.ClientSession interface provides essential methods for session management and communication:\nSessionID() string: Returns a unique identifier string for the client session. GetClientCapabilities() protocol.ClientCapabilities: Returns the capabilities object sent by the client in the initialize request. GetNegotiatedVersion() string: Returns the protocol version that was successfully negotiated during the initialization handshake. SendNotification(notification protocol.JSONRPCNotification) error: Allows the server to send an asynchronous JSON-RPC notification to this specific client session. SendResponse(response protocol.JSONRPCResponse) error: Allows the server to send a JSON-RPC response to a request. While the core server handles most responses automatically, this method is available for advanced use cases. Close() error: Terminates the connection to this client session. Logging The server.Server instance is typically configured with a logger (types.Logger). You should use this logger within your handlers for consistent and structured logging of server activity, tool execution, and errors. The logger is usually accessible via the types.SessionFromContext or by passing the logger instance down to your handlers.\npackage main import ( \"context\" \"log\" // Using standard log for simplicity in this example, but use types.Logger in practice \"github.com/localrivet/gomcp/protocol\" \"github.com/localrivet/gomcp/server\" \"github.com/localrivet/gomcp/types\" ) // Assume your server is initialized with a logger: // srv := server.NewServer(\"MyServer\", server.ServerOptions{Logger: myCustomLogger}) // Example Tool Handler demonstrating logging func handleAnotherTool(ctx context.Context, progressToken *protocol.ProgressToken, arguments any) (content []protocol.Content, isError bool) { session, ok := types.SessionFromContext(ctx) if !ok { log.Println(\"Error: ClientSession not found in context.\") return []protocol.Content{protocol.TextContent{Type: \"text\", Text: \"Internal server error: Session context missing.\"}}, true } // Access the logger associated with the session (assuming it's available via context or session) // In a real implementation, you might pass the logger to the handler closure or access it differently. // For illustrative purposes, let's assume a logger is available: // logger := getLoggerFromSomewhere() // Replace with actual logger access log.Printf(\"Executing 'anotherTool' for session %s\", session.SessionID()) // Using standard log for now log.Printf(\"Received arguments: %+v\", arguments) // ... rest of your tool handler logic ... log.Printf(\"'anotherTool' finished for session %s\", session.SessionID()) return []protocol.Content{protocol.TextContent{Type: \"text\", Text: \"Tool executed.\"}}, false } Using the server’s configured logger ensures that all logs from your handlers are processed consistently, potentially including session-specific information or routing to different outputs.\nProgress Reporting ($/progress) For long-running operations within your handlers (like complex computations, file processing, or external API calls), you can send progress notifications to the client using the $/progress notification. This allows clients to provide feedback to the user about the ongoing operation.\nTo send progress, the client must include a protocol.ProgressToken in the _meta field of their request (tools/call or resources/read). Your handler receives this token as the progressToken parameter.\nYou can then use the server.SendProgress method (which requires access to the server.Server instance) to send progress updates to the specific session.\npackage main import ( \"context\" \"fmt\" \"log\" \"time\" \"github.com/localrivet/gomcp/protocol\" \"github.com/localrivet/gomcp/server\" \"github.com/localrivet/gomcp/types\" ) // Assume srv is your initialized *server.Server instance, accessible in the handler via closure or other means. // Example Tool Handler demonstrating progress reporting func handleLongRunningTool(srv *server.Server) hooks.FinalToolHandler { // Handler factory using closure return func(ctx context.Context, progressToken *protocol.ProgressToken, arguments any) (content []protocol.Content, isError bool) { session, ok := types.SessionFromContext(ctx) if !ok { log.Println(\"Error: ClientSession not found in context.\") return []protocol.Content{protocol.TextContent{Type: \"text\", Text: \"Internal server error: Session context missing.\"}}, true } sessionID := session.SessionID() log.Printf(\"Long running tool started for session: %s\", sessionID) if progressToken != nil { // Send initial progress report if the client provided a token progressParams := protocol.ProgressParams{ Token: *progressToken, // Use the token provided by the client Value: map[string]interface{}{ \"message\": \"Starting operation...\", \"percent\": 0, }, } if err := srv.SendProgress(sessionID, progressParams); err != nil { log.Printf(\"Failed to send initial progress to session %s: %v\", sessionID, err) } else { log.Printf(\"Sent initial progress for session %s, token %v\", sessionID, *progressToken) } } // Simulate work with progress updates and cancellation checks totalSteps := 5 for i := 1; i \u003c= totalSteps; i++ { select { case \u003c-ctx.Done(): // Check for cancellation signal from the context log.Printf(\"Long running tool cancelled for session %s\", sessionID) return []protocol.Content{protocol.TextContent{Type: \"text\", Text: \"Operation cancelled.\"}}, true case \u003c-time.After(1 * time.Second): // Simulate a step of work log.Printf(\"Working on step %d for session %s\", i, sessionID) if progressToken != nil { // Send progress update progressParams := protocol.ProgressParams{ Token: *progressToken, Value: map[string]interface{}{ \"message\": fmt.Sprintf(\"Processing step %d of %d...\", i, totalSteps), \"percent\": (i * 100) / totalSteps, }, } if err := srv.SendProgress(sessionID, progressParams); err != nil { log.Printf(\"Failed to send progress update to session %s: %v\", sessionID, err) } else { log.Printf(\"Sent progress update for session %s, token %v, percent %d\", sessionID, *progressToken, (i*100)/totalSteps) } } } } if progressToken != nil { // Send final progress report progressParams := protocol.ProgressParams{ Token: *progressToken, Value: map[string]interface{}{ \"message\": \"Operation complete.\", \"percent\": 100, }, } if err := srv.SendProgress(sessionID, progressParams); err != nil { log.Printf(\"Failed to send final progress to session %s: %v\", sessionID, err) } else { log.Printf(\"Sent final progress for session %s, token %v\", sessionID, *progressToken) } } log.Printf(\"Long running tool finished for session: %s\", sessionID) return []protocol.Content{protocol.TextContent{Type: \"text\", Text: \"Operation completed successfully.\"}}, false } } // When registering the handler, use the factory: // srv := server.NewServer(...) // srv.RegisterTool(longRunningToolDefinition, handleLongRunningTool(srv)) // Pass srv to the factory The protocol.ProgressParams struct contains the Token (matching the client’s token) and a Value, which is an arbitrary JSON object containing the progress details (e.g., message, percentage).\nCancellation ($/cancelled) Clients can request the cancellation of a long-running request by sending a $/cancelled notification with the ID of the request they wish to cancel. The GoMCP server automatically handles this notification and cancels the context.Context that was passed to your handler for that specific request.\nYour handler should monitor the provided context.Context (ctx) for cancellation signals. The ctx.Done() method returns a channel that is closed when the context is cancelled. You should check this channel periodically, especially before or during potentially blocking operations, and return early if a cancellation signal is received.\n// Inside your handler function: func handleCancellableTool(ctx context.Context, progressToken *protocol.ProgressToken, arguments any) (content []protocol.Content, isError bool) { // ... setup ... select { case \u003c-ctx.Done(): // Cancellation requested log.Println(\"Operation cancelled via context.\") return []protocol.Content{protocol.TextContent{Type: \"text\", Text: \"Operation cancelled.\"}}, true default: // Not cancelled, proceed with work } // Example of checking cancellation within a loop: for i := 0; i \u003c 100; i++ { select { case \u003c-ctx.Done(): log.Println(\"Operation cancelled during loop.\") return []protocol.Content{protocol.TextContent{Type: \"text\", Text: \"Operation cancelled.\"}}, true default: // Perform a small piece of work time.Sleep(100 * time.Millisecond) } } // ... rest of handler logic ... return []protocol.Content{protocol.TextContent{Type: \"text\", Text: \"Operation completed.\"}}, false } By checking \u003c-ctx.Done(), your handlers can gracefully respond to client cancellation requests, preventing unnecessary resource usage for operations that are no longer needed.","logging#Logging":"","progress-reporting-progress#Progress Reporting (\u003ccode\u003e$/progress\u003c/code\u003e)":""},"title":"Context"},"/servers/defining-tools/":{"data":{"":"","#":"Tools allow clients (like LLMs) to perform actions by executing functions on your server. Use server.AddTool for easy registration with automatic schema generation based on a Go struct for arguments.\npackage main import ( \"github.com/localrivet/gomcp/protocol\" \"github.com/localrivet/gomcp/server\" // ... other imports ) // Define the arguments struct for your tool type ReverseArgs struct { Input string `json:\"input\" description:\"The string to reverse\" required:\"true\"` } // Your tool handler function func reverseStringHandler(args ReverseArgs) (protocol.Content, error) { runes := []rune(args.Input) for i, j := 0, len(runes)-1; i \u003c j; i, j = i+1, j-1 { runes[i], runes[j] = runes[j], runes[i] } reversed := string(runes) return server.Text(reversed), nil // Helper for simple text responses } func registerTools(srv *server.Server) error { // Register the tool using the helper err := server.AddTool( srv, \"reverse_string\", \"Reverses the input string.\", reverseStringHandler, // Pass the handler function ) return err } Alternatively, you can provide a protocol.ToolDefinition manually for more control.\nAlternative: Using RegisterTool and schema.FromStruct For more direct control over the tool definition and handler signature, you can use srv.RegisterTool and explicitly generate the schema using schema.FromStruct from the util/schema package.\nThis approach requires you to manually handle argument parsing within your handler function, which receives the raw protocol.ToolCall.\npackage main import ( \"encoding/json\" \"fmt\" \"log\" \"github.com/localrivet/gomcp/protocol\" \"github.com/localrivet/gomcp/server\" \"github.com/localrivet/gomcp/util/schema\" // Import schema helper // ... other imports ) // Define the arguments struct (still useful for schema generation) type MultiplyArgs struct { X float64 `json:\"x\" description:\"Multiplicand\" required:\"true\"` Y float64 `json:\"y\" description:\"Multiplier\" required:\"true\"` } // Handler function for RegisterTool takes protocol.ToolCall func multiplyHandler(call protocol.ToolCall) (protocol.ToolResult, error) { var args MultiplyArgs // Manually parse arguments if err := json.Unmarshal(call.Arguments, \u0026args); err != nil { log.Printf(\"[multiplyHandler] Error parsing args: %v\", err) // Return a structured error result return protocol.ToolResult{IsError: true, Content: []protocol.Content{server.Text(fmt.Sprintf(\"Invalid arguments: %v\", err))}}, nil } result := args.X * args.Y log.Printf(\"[multiply tool] %f * %f -\u003e %f\", args.X, args.Y, result) // Return a successful result return protocol.ToolResult{Content: []protocol.Content{server.Text(fmt.Sprintf(\"%f\", result))}}, nil } func registerToolsManually(srv *server.Server) { // Register the tool using RegisterTool srv.RegisterTool( protocol.Tool{ // Define the full Tool struct Name: \"multiply\", Description: \"Multiplies two numbers.\", // Generate schema explicitly InputSchema: schema.FromStruct(MultiplyArgs{}), // OutputSchema can also be defined here if needed }, multiplyHandler, // Pass the handler with the (ToolCall) signature ) // Note: Error handling for RegisterTool might differ or be absent // depending on the implementation version or desired behavior. // Check server implementation details if needed. } tools/list Request Clients can request a list of all registered tools.\nMethod: \"tools/list\" Parameters: (None) Result: protocol.ListToolsResult type ListToolsResult struct { Tools []protocol.Tool `json:\"tools\"` // List of registered tools } This request allows clients to discover the tools available on the server, including their names, descriptions, and input schemas.\nnotifications/tools/list_changed Notification Servers can send the notifications/tools/list_changed notification to inform clients that the list of available tools has changed and they should re-list if they need the updated list.\nMethod: \"notifications/tools/list_changed\" Parameters: protocol.ToolsListChangedParams (currently empty) type ToolsListChangedParams struct{} // Currently empty This notification does not include the updated list itself, only signals that a change has occurred. Clients must send a tools/list request to get the new list.","3-register-the-tool-with-the-server#3. Register the Tool with the Server":"Finally, use the RegisterTool method on your server.Server instance before running the server. Pass the protocol.Tool definition and the corresponding handler function.\nimport ( \"context\" \"log\" \"os\" \"github.com/localrivet/gomcp/protocol\" \"github.com/localrivet/gomcp/server\" \"github.com/localrivet/gomcp/util/schema\" ) // Assume echoTool definition (protocol.Tool) and // handleEchoTool (hooks.FinalToolHandler) are defined as above. func main() { // Configure logger log.SetOutput(os.Stderr) log.SetFlags(log.Ltime | log.Lshortfile) // Create the server instance srv := server.NewServer(\"MyToolServer\", server.ServerOptions{}) // Register the echo tool and its handler err := srv.RegisterTool(echoTool, handleEchoTool) if err != nil { log.Fatalf(\"Failed to register tool '%s': %v\", echoTool.Name, err) } log.Printf(\"Registered tool: %s\", echoTool.Name) // Start the server using stdio (or another transport) log.Println(\"Starting server on stdio...\") if err := server.ServeStdio(srv); err != nil { log.Fatalf(\"Server exited with error: %v\", err) } log.Println(\"Server stopped.\") } Now, when a client connects and sends a tools/call request for the “echo” tool with valid arguments, the handleEchoTool function will be executed, and its result will be sent back to the client. If the client sends a tools/list request, the echoTool definition will be included in the response."},"title":"Tools"},"/servers/prompts/":{"data":{"":"","#":"","next-steps#Next Steps":" Implement the server-side logic to handle prompts/get requests and perform argument substitution. This is a key step to make your prompt templates fully functional. Consider how to manage and load prompt definitions in your server application, perhaps from files or a database. ","prompt-updates-notificationspromptslist_changed#Prompt Updates (\u003ccode\u003enotifications/prompts/list_changed\u003c/code\u003e)":"Prompts define reusable templates or interaction patterns for the client (often an LLM). Use server.AddPrompt.\npackage main import ( \"fmt\" \"net/url\" \"github.com/localrivet/gomcp/protocol\" \"github.com/localrivet/gomcp/server\" // ... other imports ) // Prompt handler func handleSummarizePrompt(uri *url.URL, args map[string]interface{}) (protocol.Content, error) { text, _ := args[\"text\"].(string) // Basic argument handling prompt := fmt.Sprintf(\"Please summarize the following text concisely: %s\", text) return server.Text(prompt), nil } func registerPrompts(srv *server.Server) error { err := srv.AddPrompt(protocol.PromptDefinition{ URI: \"prompt://tasks/summarize\", Description: \"Generate a prompt asking the LLM to summarize text.\", Arguments: \u0026protocol.JSONSchema{ // Define expected arguments Type: \"object\", Properties: map[string]*protocol.JSONSchema{ \"text\": {Type: \"string\", Description: \"The text to summarize.\"}, }, Required: []string{\"text\"}, }, Handler: handleSummarizePrompt, }) return err } prompts/list Request Clients can request a list of all registered prompts.\nMethod: \"prompts/list\" Parameters: (None) Result: protocol.ListPromptsResult type ListPromptsResult struct { Prompts []protocol.Prompt `json:\"prompts\"` // List of registered prompts } This request allows clients to discover the prompts available on the server, including their titles, descriptions, and message templates.\nnotifications/prompts/list_changed Notification Clients can be notified when the list of available prompts changes.\nMethod: \"notifications/prompts/list_changed\" Parameters: protocol.PromptsListChangedParams (currently empty) type PromptsListChangedParams struct{} // Currently empty This notification does not include the updated list itself, only signals that a change has occurred. Clients must send a prompts/list request to get the new list.\nRetrieving Prompt Content (prompts/get) Clients can retrieve the full definition of a registered prompt, with arguments potentially filled in, using the prompts/get request. The client provides the prompt’s URI and a map of argument values. The server is expected to substitute these values into the prompt template’s message content.\nNote: In the current version of the gomcp library, the server-side implementation for handling the prompts/get request is a stub and does not yet perform argument substitution or return the full prompt definition with substituted values. This functionality is planned for future development.\nCurrently, you can register prompt metadata, and clients can discover these prompts using prompts/list, but they will receive a “Prompt not found” error if they attempt to retrieve the filled-in content using prompts/get.\nImplementing the prompts/get handler will involve:\nReceiving the prompts/get request with the prompt URI and argument values. Looking up the prompt template based on the URI. Performing argument substitution within the message content of the prompt template. Returning the updated protocol.Prompt struct in a protocol.GetPromptResult. Prompt Updates (notifications/prompts/list_changed) If a prompt’s definition changes after it has been registered (e.g., you update the template or add/remove arguments), the server can notify clients by calling server.SendPromptsListChanged(). This sends a notifications/prompts/list_changed notification to all sessions, indicating that the list of available prompts may have changed and clients should re-list using prompts/list if they need the latest definitions.\n// Assume srv is your initialized *server.Server instance // Assume updatedPrompt is the protocol.Prompt with the new definition func updatePromptAndNotify(srv *server.Server, updatedPrompt protocol.Prompt) { // First, update the prompt's definition in the server's registry. // RegisterPrompt also updates if a prompt with the same URI already exists. err := srv.RegisterPrompt(updatedPrompt) if err != nil { log.Printf(\"Failed to update prompt '%s': %v\", updatedPrompt.URI, err) return } log.Printf(\"Updated prompt definition: %s\", updatedPrompt.URI) // Then, notify clients that the list of prompts has changed. // Clients will need to re-list prompts to get the updated definition. err = srv.SendPromptsListChanged() if err != nil { log.Printf(\"Failed to send prompts/list_changed notification: %v\", err) } else { log.Printf(\"Sent prompts/list_changed notification.\") } } ","retrieving-prompt-content-promptsget#Retrieving Prompt Content (\u003ccode\u003eprompts/get\u003c/code\u003e)":""},"title":"Prompts"},"/servers/resources/":{"data":{"":"","#":"Resources expose data to clients. They are primarily for providing information without significant computation or side effects (like GET requests). Use server.AddResource. Dynamic URIs with {placeholders} are supported.\npackage main import ( \"fmt\" \"net/url\" \"time\" \"github.com/localrivet/gomcp/protocol\" \"github.com/localrivet/gomcp/server\" // ... other imports ) // Static resource handler func handleAppVersion(uri *url.URL) (protocol.Content, error) { return server.Text(\"1.2.3\"), nil } // Dynamic resource handler (extracting part from URI) func handleUserData(uri *url.URL) (protocol.Content, error) { // Example URI: user://data/123/profile // We need to parse the user ID from the path userID := \"\" // Extract from uri.Path, e.g., using strings.Split // Fetch user data... userData := map[string]interface{}{ \"id\": userID, \"email\": fmt.Sprintf(\"user%s@example.com\", userID), \"lastLogin\": time.Now().Format(time.RFC3339), } return server.JSON(userData) // Helper for JSON responses } func registerResources(srv *server.Server) error { // Register a static resource err := srv.AddResource(protocol.ResourceDefinition{ URI: \"app://info/version\", Description: \"Get the application version.\", Handler: handleAppVersion, }) if err != nil { return err } // Register a dynamic resource template err = srv.AddResource(protocol.ResourceDefinition{ URI: \"user://data/{userID}/profile\", // Template URI Description: \"Get user profile data.\", IsTemplate: true, // Mark as template Handler: handleUserData, }) return err } Method: \"resources/subscribe\" Parameters: protocol.SubscribeResourceParams Result: protocol.SubscribeResourceResult (currently empty) type SubscribeResourceParams struct { URIs []string `json:\"uris\"` // List of resource URIs to subscribe to } type SubscribeResourceResult struct{} // Currently empty Clients provide a list of resource URIs they want to subscribe to. The server tracks these subscriptions per session.\nresources/unsubscribe Request Clients can unsubscribe from resource updates.\nMethod: \"resources/unsubscribe\" Parameters: protocol.UnsubscribeResourceParams Result: protocol.UnsubscribeResourceResult (currently empty) type UnsubscribeResourceParams struct { URIs []string `json:\"uris\"` // List of resource URIs to unsubscribe from } type UnsubscribeResourceResult struct{} // Currently empty Clients provide a list of resource URIs they no longer wish to receive updates for.\nresources/read Request Clients can request the content of a specific resource.\nMethod: \"resources/read\" Parameters: protocol.ReadResourceRequestParams Result: protocol.ReadResourceResult type ReadResourceRequestParams struct { URI string `json:\"uri\"` Version string `json:\"version,omitempty\"` // Optional version to request a specific version } type ReadResourceResult struct { Resource protocol.Resource `json:\"resource\"` // The resource metadata (should match the request URI/version) Contents protocol.ResourceContents `json:\"contents\"` // The actual content (Text, Blob, or Audio) } Clients specify the uri of the resource they want to read. Optionally, they can provide a version to request a specific version of the resource. The server responds with the resource’s metadata and its content, which can be text, binary (blob), or audio, represented by the ResourceContents interface and its concrete types (TextResourceContents, BlobResourceContents, AudioResourceContents).\nnotifications/resources/updated Notification Servers send the notifications/resources/updated notification to inform subscribed clients that a specific resource has been updated.\nMethod: \"notifications/resources/updated\" Parameters: protocol.ResourceUpdatedParams type ResourceUpdatedParams struct { Resource Resource `json:\"resource\"` // The updated resource metadata } The server includes the updated protocol.Resource metadata in the notification. Clients can then decide whether to re-read the resource content using resources/read.\nnotifications/resources/list_changed Notification Servers can send the notifications/resources/list_changed notification to inform clients that the list of available resources has changed (resources added or removed).\nMethod: \"notifications/resources/list_changed\" Parameters: protocol.ResourcesListChangedParams (currently empty) type ResourcesListChangedParams struct{} // Currently empty This notification does not include the updated list itself, only signals that a change has occurred. Clients must send a resources/list request to get the new list.","next-steps#Next Steps":" Implement the server-side logic to handle resources/read requests and provide resource content. This is a key step to make your resources fully functional. Explore the protocol package for the different ResourceContents types you can use to represent various data formats. Integrate resource definition, registration, and update notification into your server application’s data management logic. ","resource-updates-and-subscriptions#Resource Updates and Subscriptions":"Clients can subscribe to resource updates using the resources/subscribe request. This allows them to receive notifications when a resource’s content or metadata changes without constantly polling the server.\nThe server tracks which sessions have subscribed to which resource URIs. When a resource is updated in your application, you can notify subscribed clients by calling server.NotifyResourceUpdated(updatedResource).\n// Assume srv is your initialized *server.Server instance // Assume updatedResource is the protocol.Resource with the new metadata/version func updateResourceAndNotify(srv *server.Server, updatedResource protocol.Resource) { // First, update the resource's metadata in the server's registry. // RegisterResource also updates if a resource with the same URI already exists. err := srv.RegisterResource(updatedResource) if err != nil { log.Printf(\"Failed to update resource '%s': %v\", updatedResource.URI, err) return } log.Printf(\"Updated resource metadata: %s\", updatedResource.URI) // Then, notify subscribed clients about the update. // The server will automatically send a notifications/resources/updated // message to all sessions that subscribed to this resource's URI. srv.NotifyResourceUpdated(updatedResource) log.Printf(\"Sent resources/updated notification for: %s\", updatedResource.URI) // Note: Clients receiving this notification will typically then send a // resources/read request to get the new content if they need it. } Clients can unsubscribe from resource updates using the resources/unsubscribe request."},"title":"Resources"}}