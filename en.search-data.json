{"/docs/":{"data":{"":"","communication-flow#Communication Flow":"","core-components#Core Components":"","next-steps--future-development#Next Steps \u0026amp; Future Development":"The primary goal of gomcp is to provide idiomatic Go tools for building applications that communicate using the Model Context Protocol (MCP). This includes:\nMCP Servers: Applications that expose tools or resources to MCP clients (often language models or agents). MCP Clients: Applications that connect to MCP servers to utilize their offered tools and resources. Core Components The library is structured into several key packages:\nprotocol/:\nDefines Go structs mapping to MCP concepts (e.g., Tool, Resource, Prompt, ClientCapabilities, ServerCapabilities). Defines Go structs for specific request parameters and results (e.g., InitializeRequestParams, InitializeResult, CallToolParams, CallToolResult). Defines Go structs for JSON-RPC 2.0 base messages (JSONRPCRequest, JSONRPCResponse, JSONRPCNotification) and error payloads (ErrorPayload). Includes constants for MCP method names (e.g., MethodInitialize, MethodCallTool, MethodCancelled) and the supported protocol version (CurrentProtocolVersion). Uses standard Go encoding/json tags. For detailed descriptions of the protocol messages and structures, see the Protocols section, including: Messages Tools Resources Prompts server/:\nDefines the Server struct, containing the core transport-agnostic MCP server logic. NewServer initializes a server instance, taking server info and options (like a logger). RegisterTool, RegisterResource, RegisterPrompt allow adding capabilities dynamically. These methods trigger list_changed notifications if supported. RegisterNotificationHandler allows handling client-sent notifications (e.g., $/cancelled). HandleMessage is the main entry point for processing incoming raw messages (typically called by a transport implementation). It handles the initialization sequence and dispatches requests/notifications to internal handlers. Internal handlers (handle...) are responsible for unmarshalling parameters, performing actions (like calling a registered ToolHandlerFunc), and generating responses/errors. Includes Send... methods for server-initiated notifications (SendProgress, SendResourceChanged, etc.), which are typically invoked via a ClientSession interface implemented by the transport layer. client/:\nDefines the Client struct for managing the client-side connection, currently implemented using the SSE+HTTP hybrid transport model. NewClient initializes a client instance, requiring the server’s base URL and other options. RegisterRequestHandler, RegisterNotificationHandler allow handling server-sent requests/notifications received over SSE. Connect establishes the SSE connection and performs the MCP initialization handshake (sending initialize via HTTP POST, receiving response via SSE, sending initialized via HTTP POST). Provides methods for sending specific MCP requests (e.g., ListTools, CallTool, SubscribeResources). These methods typically send the request via HTTP POST and wait for the response via the SSE connection. Manages pending requests and dispatches incoming SSE messages (responses, notifications, requests) appropriately. Includes Send... methods for client-initiated notifications (SendCancellation, SendRootsListChanged). transport/:\nContains different transport implementations. stdio/: Provides a StdioTransport that implements the types.Transport interface for communication over standard input/output (newline-delimited JSON). Useful for simple cases or testing. sse/: Provides an SSEServer that handles the server-side of the SSE+HTTP hybrid transport (SSE for server-\u003eclient, HTTP POST for client-\u003eserver). The client package uses an SSE client library (github.com/r3labs/sse/v2) internally to connect to this. (Other transports like WebSockets or TCP could be added here in the future.) Key Design Point: The separation between the server package (core logic) and the transport implementations (message sending/receiving) is intentional. It allows developers to integrate the gomcp server with various communication methods by implementing the types.Transport interface. This provides flexibility for different deployment scenarios or custom protocols built on top of MCP. types/: Defines core interfaces like Transport and Logger used across packages. Communication Flow The library supports multiple communication methods:\nStdio Transport (transport/stdio) +--------------+ Stdio Pipe +-------------+ | | \u003c--- JSON Lines ---- | | | MCP Client | (Stdin) | MCP Server | | (App/Script) | | (App/Script)| | | ---- JSON Lines ---\u003e | | +--------------+ (Stdout) +-------------+ Simple, direct communication via stdin/stdout. Suitable for local inter-process communication or basic examples. The StdioTransport handles reading/writing newline-delimited JSON. SSE + HTTP Hybrid Transport (transport/sse + client) +--------------+ +-----------------+ | | ---- HTTP POST Req ---\u003e | | | MCP Client | (e.g., initialize, | MCP Server | | (Using client| callTool, initialized) | (Using sse pkg) | | package) | | | | | \u003c--- HTTP POST Resp --- | | +--------------+ (e.g., callTool result) +-----------------+ | ^ | Establish \u0026 Maintain SSE Connection | SSE Events +--------\u003c---- SSE Events --------------+ (e.g., endpoint, (e.g., initialize result, message (notifications, notifications, server reqs)) server requests)) Client -\u003e Server: Requests (initialize, callTool) and Notifications (initialized, $/cancelled) are sent via HTTP POST requests to a specific message endpoint on the server. Responses to these requests (like callTool results) are sent back in the HTTP response body. Server -\u003e Client: The client establishes a persistent Server-Sent Events (SSE) connection. The server sends asynchronous messages (like initialize results, notifications, or server-to-client requests) over this SSE connection. This is the primary transport used by the client package. Next Steps \u0026 Future Development The core library is now compliant with the defined features of the MCP 2025-03-26 specification. Future work includes:\nExample Updates: Ensure all examples in examples/ are up-to-date with the latest library structure and demonstrate features like cancellation, progress, and subscriptions effectively across different transports. Testing: Add more comprehensive unit and integration tests, especially covering notifications, subscriptions, cancellation, concurrency, and different transport layers. Progress Reporting: Address the issue where the ToolHandlerFunc doesn’t have direct access to the sessionID needed for server.SendProgress. This might require API changes or alternative patterns. Protocol Enhancements: Implement optional fields mentioned in the spec (e.g., trace, workspaceFolders, filtering options, content annotations). Error Handling: Refine error reporting and potentially add more specific MCP error codes for implementation-defined errors. Alternative Transports: Add examples or support for transports beyond stdio and SSE (e.g., WebSockets, TCP). Documentation: Enhance GoDoc comments and keep /docs guides up-to-date. "},"title":"Documentation"},"/docs/calling-tools/":{"data":{"":"","example-calling-an-echo-tool#Example: Calling an \u0026ldquo;echo\u0026rdquo; Tool":"Once your MCP client is connected to a server, you can execute the tools the server offers using the tools/call request. The gomcp/client package provides the CallTool method to simplify this process.\nSteps to Call a Tool Identify the Tool: Know the Name of the tool you want to call (e.g., by using ListTools first). Prepare Arguments: Construct the arguments required by the tool, matching its defined InputSchema. This can be a map[string]interface{} or a struct that marshals to the expected JSON object. Create CallToolParams: Populate a protocol.CallToolParams struct with the tool Name and the prepared Arguments. (Optional) Request Progress: If the tool supports progress reporting and the server advertises the capability, you can generate a unique protocol.ProgressToken and include it in the Meta field of CallToolParams. You also need to register a handler for $/progress notifications before connecting. Call client.CallTool: Invoke the CallTool method on your connected client.Client instance, passing a context.Context (for cancellation/timeout of the specific call), the CallToolParams, and the progress token (if generated). Handle Result/Error: If CallTool returns a non-nil error, it indicates a protocol-level issue (e.g., connection lost, invalid response format). If error is nil, check the IsError field within the returned protocol.CallToolResult. If true, the tool execution failed on the server, and the Content field likely contains error details (e.g., a TextContent message). If IsError is false (or nil), the call was successful, and the Content field contains the tool’s output (e.g., TextContent, ImageContent). Example: Calling an “echo” Tool This example assumes a client.Client (clt) has already been created and connected to a server offering an “echo” tool.\npackage main import ( \"context\" \"log\" \"os\" \"time\" \"github.com/localrivet/gomcp/client\" \"github.com/localrivet/gomcp/protocol\" // \"github.com/google/uuid\" // Needed if generating progress tokens ) func main() { // Configure logger log.SetOutput(os.Stderr) log.SetFlags(log.Ltime | log.Lshortfile) log.Println(\"Starting Tool Calling Client...\") // Create a stdio client (replace with NewClient for network) clt, err := client.NewStdioClient(\"MyToolCaller\", client.ClientOptions{}) if err != nil { log.Fatalf(\"Failed to create client: %v\", err) } // Connect to the server (assumes a compatible server is running) ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second) defer cancel() err = clt.Connect(ctx) if err != nil { log.Fatalf(\"Client failed to connect: %v\", err) } defer clt.Close() log.Printf(\"Connected to server: %s\", clt.ServerInfo().Name) // --- Call a Tool --- // 1. Define the arguments for the tool call. // This should match the tool's InputSchema. toolArgs := map[string]interface{}{ \"input\": \"Hello from client!\", \"prefix\": \"[MCP] \", } // 2. Create the CallToolParams struct. callParams := protocol.CallToolParams{ Name: \"echo\", // The name of the tool to call Arguments: toolArgs, // Meta: nil, // Optional: Include metadata like progress token } // Example: Requesting progress updates (optional) // var progressToken *protocol.ProgressToken // if clt.ServerCapabilities().Tools != nil \u0026\u0026 clt.ServerCapabilities().Tools.Progress { // token := protocol.ProgressToken(uuid.NewString()) // progressToken = \u0026token // callParams.Meta = \u0026protocol.RequestMeta{ProgressToken: progressToken} // // Need to register a handler for $/progress notifications *before* connecting // // clt.RegisterNotificationHandler(protocol.MethodProgress, handleProgress) // log.Printf(\"Requesting progress with token: %s\", *progressToken) // } // 3. Call the tool using the client's CallTool method. // Provide a context for the specific call. callCtx, callCancel := context.WithTimeout(ctx, 15*time.Second) defer callCancel() log.Printf(\"Calling tool '%s' with args: %+v\", callParams.Name, callParams.Arguments) result, err := clt.CallTool(callCtx, callParams, progressToken) // Pass progress token if created // 4. Handle the result or error. if err != nil { // This indicates a protocol-level error (e.g., connection issue, invalid response) log.Printf(\"ERROR calling tool '%s': %v\", callParams.Name, err) } else { // Check the IsError flag in the result for application-level errors log.Printf(\"Tool '%s' call finished. IsError: %v\", callParams.Name, result.IsError) log.Printf(\" Result Content (%d items):\", len(result.Content)) for i, contentItem := range result.Content { log.Printf(\" - [%d] Type: %s\", i, contentItem.ContentType()) // Process specific content types (e.g., TextContent) if textContent, ok := contentItem.(protocol.TextContent); ok { log.Printf(\" Text: %s\", textContent.Text) } // Add checks for other types like ImageContent, JSONContent, etc. } } log.Println(\"Client finished.\") } // Example progress handler (if needed) // func handleProgress(ctx context.Context, params any) error { // progressParams, ok := params.(protocol.ProgressParams) // if !ok { // log.Printf(\"WARN: Received progress notification with unexpected param type: %T\", params) // return nil // } // log.Printf(\"PROGRESS [%s]: %v\", progressParams.Token, progressParams.Value) // return nil // } ","steps-to-call-a-tool#Steps to Call a Tool":""},"title":"Calling Server Tools"},"/docs/code-organization/":{"data":{"":"","communication-flow#Communication Flow":"","core-components#Core Components":"","goal#Goal":"","next-steps--future-development#Next Steps \u0026amp; Future Development":"Goal The primary goal of gomcp is to provide idiomatic Go tools for building applications that communicate using the Model Context Protocol (MCP). This includes:\nMCP Servers: Applications that expose tools or resources to MCP clients (often language models or agents). MCP Clients: Applications that connect to MCP servers to utilize their offered tools and resources. Core Components The library is structured into several key packages:\nprotocol/:\nDefines Go structs mapping to MCP concepts (e.g., Tool, Resource, Prompt, ClientCapabilities, ServerCapabilities). Defines Go structs for specific request parameters and results (e.g., InitializeRequestParams, InitializeResult, CallToolParams, CallToolResult). Defines Go structs for JSON-RPC 2.0 base messages (JSONRPCRequest, JSONRPCResponse, JSONRPCNotification) and error payloads (ErrorPayload). Includes constants for MCP method names (e.g., MethodInitialize, MethodCallTool, MethodCancelled) and the supported protocol version (CurrentProtocolVersion). Uses standard Go encoding/json tags. For detailed descriptions of the protocol messages and structures, see the Protocols section, including: Messages Tools Resources Prompts server/:\nDefines the Server struct, containing the core transport-agnostic MCP server logic. NewServer initializes a server instance, taking server info and options (like a logger). RegisterTool, RegisterResource, RegisterPrompt allow adding capabilities dynamically. These methods trigger list_changed notifications if supported. RegisterNotificationHandler allows handling client-sent notifications (e.g., $/cancelled). HandleMessage is the main entry point for processing incoming raw messages (typically called by a transport implementation). It handles the initialization sequence and dispatches requests/notifications to internal handlers. Internal handlers (handle...) are responsible for unmarshalling parameters, performing actions (like calling a registered ToolHandlerFunc), and generating responses/errors. Includes Send... methods for server-initiated notifications (SendProgress, SendResourceChanged, etc.), which are typically invoked via a ClientSession interface implemented by the transport layer. client/:\nDefines the Client struct for managing the client-side connection, currently implemented using the SSE+HTTP hybrid transport model. NewClient initializes a client instance, requiring the server’s base URL and other options. RegisterRequestHandler, RegisterNotificationHandler allow handling server-sent requests/notifications received over SSE. Connect establishes the SSE connection and performs the MCP initialization handshake (sending initialize via HTTP POST, receiving response via SSE, sending initialized via HTTP POST). Provides methods for sending specific MCP requests (e.g., ListTools, CallTool, SubscribeResources). These methods typically send the request via HTTP POST and wait for the response via the SSE connection. Manages pending requests and dispatches incoming SSE messages (responses, notifications, requests) appropriately. Includes Send... methods for client-initiated notifications (SendCancellation, SendRootsListChanged). transport/:\nContains different transport implementations. stdio/: Provides a StdioTransport that implements the types.Transport interface for communication over standard input/output (newline-delimited JSON). Useful for simple cases or testing. sse/: Provides an SSEServer that handles the server-side of the SSE+HTTP hybrid transport (SSE for server-\u003eclient, HTTP POST for client-\u003eserver). The client package uses an SSE client library (github.com/r3labs/sse/v2) internally to connect to this. (Other transports like WebSockets or TCP could be added here in the future.) types/:\nDefines core interfaces like Transport and Logger used across packages. Communication Flow The library supports multiple communication methods:\nStdio Transport (transport/stdio) +--------------+ Stdio Pipe +-------------+ | | \u003c--- JSON Lines ---- | | | MCP Client | (Stdin) | MCP Server | | (App/Script) | | (App/Script)| | | ---- JSON Lines ---\u003e | | +--------------+ (Stdout) +-------------+ Simple, direct communication via stdin/stdout. Suitable for local inter-process communication or basic examples. The StdioTransport handles reading/writing newline-delimited JSON. SSE + HTTP Hybrid Transport (transport/sse + client) +--------------+ +-----------------+ | | ---- HTTP POST Req ---\u003e | | | MCP Client | (e.g., initialize, | MCP Server | | (Using client| callTool, initialized) | (Using sse pkg) | | package) | | | | | \u003c--- HTTP POST Resp --- | | +--------------+ (e.g., callTool result) +-----------------+ | ^ | Establish \u0026 Maintain SSE Connection | SSE Events +--------\u003c---- SSE Events --------------+ (e.g., endpoint, (e.g., initialize result, message (notifications, notifications, server reqs)) server requests)) Client -\u003e Server: Requests (initialize, callTool) and Notifications (initialized, $/cancelled) are sent via HTTP POST requests to a specific message endpoint on the server. Responses to these requests (like callTool results) are sent back in the HTTP response body. Server -\u003e Client: The client establishes a persistent Server-Sent Events (SSE) connection. The server sends asynchronous messages (like initialize results, notifications, or server-to-client requests) over this SSE connection. This is the primary transport used by the client package. Next Steps \u0026 Future Development The core library is now compliant with the defined features of the MCP 2025-03-26 specification. Future work includes:\nExample Updates: Ensure all examples in examples/ are up-to-date with the latest library structure and demonstrate features like cancellation, progress, and subscriptions effectively across different transports. Testing: Add more comprehensive unit and integration tests, especially covering notifications, subscriptions, cancellation, concurrency, and different transport layers. Progress Reporting: Address the issue where the ToolHandlerFunc doesn’t have direct access to the sessionID needed for server.SendProgress. This might require API changes or alternative patterns. Protocol Enhancements: Implement optional fields mentioned in the spec (e.g., trace, workspaceFolders, filtering options, content annotations). Error Handling: Refine error reporting and potentially add more specific MCP error codes for implementation-defined errors. Alternative Transports: Add examples or support for transports beyond stdio and SSE (e.g., WebSockets, TCP). Documentation: Enhance GoDoc comments and keep /docs guides up-to-date. "},"title":"Package Organization"},"/docs/create-client/":{"data":{"":"","choosing-a-transport#Choosing a Transport":"The gomcp client library supports multiple transport mechanisms to communicate with MCP servers. The choice of transport depends on the server’s implementation and the desired protocol version compatibility.\nThe client package provides specific constructors for each supported transport:\nclient.NewSSEClient(baseURL, basePath, opts):\nUses the HTTP+SSE transport. Suitable for connecting to servers implementing the 2024-11-05 specification’s transport model. Requires the server’s base HTTP URL (e.g., http://localhost:8080) and the MCP base path (e.g., /mcp). client.NewWebSocketClient(wsURL, opts):\nUses the WebSocket transport. Suitable for connecting to servers implementing the 2025-03-26 specification’s “Streamable HTTP” transport model. Requires the server’s WebSocket URL (e.g., ws://localhost:8080/mcp). client.NewStdioClient(clientName, opts):\nUses Standard Input/Output (Stdio). Suitable for communicating with a server running as a local child process, where the client reads from the server’s stdout and writes to its stdin. client.NewTCPClient(addr, opts):\nUses a raw TCP socket connection. Suitable for connecting to servers listening on a specific TCP address (e.g., localhost:6000). When creating a client, select the constructor that matches the transport mechanism used by the target MCP server. The ClientOptions struct allows further customization, such as providing a logger or specifying client capabilities and the preferred protocol version for the handshake.","client-role#Client Role":"","handling-server-messages#Handling Server Messages":"Use RegisterNotificationHandler and RegisterRequestHandler before calling Connect to set up functions that will be called when the server sends asynchronous notifications or requests over the established transport connection.","initializing-the-client-client-package#Initializing the Client (\u003ccode\u003eclient\u003c/code\u003e package)":"The gomcp library provides tools for building applications that act as MCP clients, connecting to MCP servers to utilize their capabilities (tools, resources, prompts).\nThe primary implementation for a client is found in the client package. This package provides the core client logic, while specific transport mechanisms (like SSE+HTTP, WebSocket, Stdio, TCP) are handled by dedicated constructors and implementations conforming to the types.Transport interface.\nClient Role An MCP client typically:\nConnects to a known MCP server endpoint. Performs the initialization handshake (initialize / initialized). Discovers available server capabilities (tools, resources, prompts) using list requests. Executes server tools (tools/call). Accesses server resources (resources/get). Subscribes to resource updates (resources/subscribe). Handles server-sent notifications (e.g., $/progress, notifications/message). Handles server-sent requests (if the server needs to request actions from the client, though less common). Initializing the Client (client package) The client package provides a Client struct that manages the connection and communication flow. It works with different underlying transport mechanisms provided during initialization.\npackage main import ( \"context\" \"log\" \"os\" \"time\" \"github.com/localrivet/gomcp/client\" \"github.com/localrivet/gomcp/protocol\" // types package might not be needed directly for basic client setup ) func main() { // Configure logger log.SetOutput(os.Stderr) log.SetFlags(log.Ltime | log.Lshortfile) log.Println(\"Starting Simple Stdio MCP Client...\") // 1. Create Client Instance for Stdio // NewStdioClient handles stdio transport setup internally. // Provide a client name and optional ClientOptions. // This example uses NewStdioClient for simplicity. // For network connections, you would typically use: // - client.NewSSEClient (for 2024-11-05 compatible servers using HTTP+SSE) // - client.NewWebSocketClient (for 2025-03-26 compatible servers using WebSocket) // - client.NewTCPClient (for raw TCP connections) clt, err := client.NewStdioClient(\"my-stdio-client\", client.ClientOptions{ // ClientCapabilities can be customized here if needed. // Example: // ClientCapabilities: protocol.ClientCapabilities{ /* ... */ }, // Logger: provide a custom logger if desired // PreferredProtocolVersion: \u0026protocol.CurrentProtocolVersion, // Optionally specify preferred version }) if err != nil { log.Fatalf(\"Failed to create stdio client: %v\", err) } // 2. Connect and Initialize // Use a context for timeout/cancellation for the connection attempt. ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second) defer cancel() log.Println(\"Connecting to server via stdio...\") // Connect performs the MCP initialization handshake over stdio. err = clt.Connect(ctx) if err != nil { log.Fatalf(\"Failed to connect and initialize with server: %v\", err) } // For stdio, Close is often handled implicitly when stdin/stdout close, // but deferring it ensures cleanup if the client exits early. defer clt.Close() // 3. Access Server Information (Post-Connection) // Once connected, you can get info about the server. serverInfo := clt.ServerInfo() log.Printf(\"Connected to server: %s (Version: %s)\", serverInfo.Name, serverInfo.Version) log.Printf(\"Server capabilities: %+v\", clt.ServerCapabilities()) // --- Client is now ready to make requests --- // Example: List available tools from the server // Use a derived context for the specific request. listToolsCtx, listToolsCancel := context.WithTimeout(ctx, 10*time.Second) defer listToolsCancel() toolsResult, err := clt.ListTools(listToolsCtx, protocol.ListToolsRequestParams{}) if err != nil { log.Printf(\"Error listing tools: %v\", err) } else { log.Printf(\"Available tools (%d):\", len(toolsResult.Tools)) for _, tool := range toolsResult.Tools { log.Printf(\"- %s: %s\", tool.Name, tool.Description) } } // Add more client logic here (e.g., CallTool, GetResource) using the 'clt' instance. log.Println(\"Client operations finished.\") // In a real application, the client might wait for more tasks or exit. // For stdio, the client often runs until its input/output streams are closed. } Note: This example uses the simple Stdio transport. For network examples using SSE or WebSocket, see the examples/ directory.","making-requests#Making Requests":"Once connected, you can use the methods provided by the client.Client struct to interact with the server:\nListTools(ctx, params) CallTool(ctx, params) ListResources(ctx, params) GetResource(ctx, params) SubscribeResources(ctx, params) UnsubscribeResources(ctx, params) ListPrompts(ctx, params) GetPrompt(ctx, params) SendCancellation(ctx, id) SendProgress(ctx, params) // If client needs to report progress // … and others Each method takes a context.Context for cancellation and deadlines, and the corresponding parameter struct defined in the protocol package."},"title":"Creating a Client"},"/docs/create-server/":{"data":{"":"","handling-client-messages#Handling Client Messages":"The server.Server automatically handles incoming JSON-RPC requests and notifications based on the registered capabilities and standard protocol methods (initialize, $/cancelled, etc.). You generally don’t need to handle raw messages directly unless implementing custom notifications or requests.","initializing-the-server-server-package#Initializing the Server (\u003ccode\u003eserver\u003c/code\u003e package)":"The gomcp library provides the core logic for building applications that act as MCP servers, exposing capabilities like tools, resources, and prompts to connected clients.\nThe main server logic resides in the server package. This package is transport-agnostic, meaning the core server doesn’t care how messages are sent or received; that’s handled by a separate Transport implementation.\nServer Role An MCP server typically:\nListens for incoming client connections via a specific transport (e.g., Stdio, SSE+HTTP, WebSockets). Handles the initialization handshake (initialize / initialized) with connecting clients. Exposes its capabilities (server info, supported protocol features). Registers and makes available its specific offerings: Tools that clients can execute. Resources that clients can access or subscribe to. Prompts that clients can list or retrieve. Handles client requests (tools/call, resources/get, etc.) and sends back responses or errors. Handles client notifications ($/cancelled, initialized, etc.). Sends server-initiated notifications to clients ($/progress, notifications/message, notifications/resources/content_changed, etc.). Initializing the Server (server package) The server.Server struct holds the state and logic for the MCP server.\npackage main import ( \"context\" \"fmt\" \"log\" \"os\" \"github.com/localrivet/gomcp/protocol\" \"github.com/localrivet/gomcp/server\" \"github.com/localrivet/gomcp/util/schema\" // Use schema helper ) // Define arguments struct for the echo tool type EchoArgs struct { Input string `json:\"input\" description:\"Text to echo\"` } // Example Tool Handler Function using the correct signature // and schema.HandleArgs for parsing. func handleEchoTool(ctx context.Context, progressToken *protocol.ProgressToken, arguments any) (content []protocol.Content, isError bool) { args, errContent, isErr := schema.HandleArgs[EchoArgs](arguments) if isErr { log.Printf(\"Error handling echo args: %v\", errContent) return errContent, true } log.Printf(\"Executing echo tool with input: %s\", args.Input) return []protocol.Content{ protocol.TextContent{Type: \"text\", Text: \"Echo: \" + args.Input}, }, false } func main() { // Configure logger log.SetOutput(os.Stderr) log.SetFlags(log.Ltime | log.Lshortfile) // 1. Create the Server Instance // Provide a name and optional server options srv := server.NewServer(\"my-gomcp-server\", server.ServerOptions{ // Define server capabilities if needed (defaults are reasonable) ServerCapabilities: protocol.ServerCapabilities{ Tools: \u0026protocol.ToolsCaps{ListChanged: true}, // Example }, // Logger: provide a custom logger if desired }) // 2. Define and Register Capabilities (e.g., Tools) echoTool := protocol.Tool{ Name: \"echo\", Description: \"Simple tool that echoes back the input text.\", InputSchema: schema.FromStruct(EchoArgs{}), // Generate schema from struct } // Register the tool with its handler err := srv.RegisterTool(echoTool, handleEchoTool) if err != nil { log.Fatalf(\"Failed to register tool: %v\", err) } log.Printf(\"Registered tool: %s\", echoTool.Name) // Register resources and prompts similarly if needed // 3. Run the Server using a built-in transport handler // Using ServeStdio for simplicity in this example log.Println(\"Starting MCP server on stdio...\") if err := server.ServeStdio(srv); err != nil { // ServeStdio blocks until the transport is closed or an error occurs log.Fatalf(\"Server exited with error: %v\", err) } log.Println(\"Server stopped.\") } ","registering-capabilities#Registering Capabilities":" RegisterTool(tool protocol.Tool, handler server.ToolHandlerFunc): Registers a tool definition and the function that implements its logic. The handler receives the arguments provided by the client. RegisterResource(resource protocol.Resource, provider server.ResourceProvider): Registers a resource and a provider responsible for fetching its content. RegisterPrompt(prompt protocol.Prompt): Registers a predefined prompt template. See Defining Tools for more details on tool registration. (Resource and Prompt registration follow similar patterns).","running-the-server#Running the Server":" Run(transport types.Transport): Starts the server’s main loop, using the provided transport to receive messages from clients and send messages back. This method typically blocks until the transport is closed or an unrecoverable error occurs. While Run is the core method requiring a pre-configured transport, the server package also provides convenience functions to quickly start a server with common transport mechanisms:\nServeStdio(srv *Server): Runs the server using Standard Input/Output, suitable for local process communication. ServeSSE(srv *Server, addr string, basePath string): Runs the server using the HTTP+SSE transport (compatible with 2024-11-05 clients), listening on the specified network address (e.g., :8080) and base HTTP path (e.g., /mcp). ServeWebSocket(srv *Server, addr string, path string): Runs the server using the WebSocket transport (compatible with 2025-03-26 clients), listening on the specified network address (e.g., :8080) and WebSocket path (e.g., /mcp). ServeTCP(srv *Server, addr string): Runs the server using a raw TCP socket connection, listening on the specified network address (e.g., :6000). Choose the appropriate ServeX function based on the desired transport mechanism for your server.","sending-server-messages#Sending Server Messages":"The server can send notifications or requests to connected clients. This is usually done via the ClientSession interface, which is managed internally by the server and implemented by the transport layer. Methods like srv.SendProgress(sessionID, token, value) or srv.NotifyResourceChanged(uri) facilitate this. Accessing the correct sessionID often requires careful context management within handlers.","server-role#Server Role":""},"title":"Creating a Server"},"/docs/defining-tools/":{"data":{"":"","1-define-the-tool-structure-protocoltool#1. Define the Tool Structure (\u003ccode\u003eprotocol.Tool\u003c/code\u003e)":"","2-implement-the-tool-handler-function-servertoolhandlerfunc#2. Implement the Tool Handler Function (\u003ccode\u003eserver.ToolHandlerFunc\u003c/code\u003e)":"One of the core features of MCP is the ability for servers to expose “tools” that clients can execute. This guide explains how to define and register tools in your gomcp server application.\n1. Define the Tool Structure (protocol.Tool) First, you need to define the metadata for your tool using the protocol.Tool struct. This includes:\nName: A unique string identifier for the tool (e.g., “calculate_sum”, “read_file”). Description: (Optional) A human-readable description of what the tool does. InputSchema: A protocol.ToolInputSchema defining the expected arguments. This uses a subset of JSON Schema: Type: Should typically be “object”. Properties: A map where keys are argument names and values are protocol.PropertyDetail structs describing the argument’s Type (e.g., “string”, “number”, “boolean”, “array”, “object”), Description, allowed Enum values, or Format. Required: A slice of strings listing the names of mandatory arguments. Annotations: (Optional) A protocol.ToolAnnotations struct providing hints about the tool’s behavior (e.g., ReadOnlyHint, DestructiveHint). Example: An “echo” tool definition\nimport \"github.com/localrivet/gomcp/protocol\" var echoTool = protocol.Tool{ Name: \"echo\", Description: \"Simple tool that echoes back the input text.\", InputSchema: protocol.ToolInputSchema{ Type: \"object\", Properties: map[string]protocol.PropertyDetail{ \"input\": { Type: \"string\", Description: \"The text to be echoed back by the server.\", }, \"prefix\": { Type: \"string\", Description: \"An optional prefix to add to the echoed text.\", // Note: Not listed in 'Required', so it's optional. }, }, Required: []string{\"input\"}, // Only 'input' is mandatory }, Annotations: protocol.ToolAnnotations{ // Example annotation: This tool doesn't modify state ReadOnlyHint: func(b bool) *bool { return \u0026b }(true), }, } 2. Implement the Tool Handler Function (server.ToolHandlerFunc) Next, create a function that implements the actual logic of your tool. This function must match the server.ToolHandlerFunc signature:\ntype ToolHandlerFunc func(ctx context.Context, progressToken *protocol.ProgressToken, arguments any) (content []protocol.Content, isError bool) It receives a context.Context for cancellation/deadlines. It receives an optional *protocol.ProgressToken if the client requested progress updates for this call. It receives the arguments provided by the client in the tools/call request as an any type. You need to parse and validate these arguments, ideally using the schema.HandleArgs helper function (see below). It returns a slice of protocol.Content objects (e.g., protocol.TextContent, protocol.ImageContent) representing the result of the tool execution. It returns a boolean isError. If true, the returned content is treated as error information (e.g., a TextContent explaining the error). If false, the content is the successful result. The schema.HandleArgs helper can generate appropriate error content automatically for invalid arguments. Example: Handler for the “echo” tool\npackage main import ( \"context\" \"log\" // Added for logging \"github.com/localrivet/gomcp/protocol\" \"github.com/localrivet/gomcp/util/schema\" ) // Define arguments struct for the echo tool type EchoArgs struct { Input string `json:\"input\" description:\"The text to be echoed back by the server.\"` Prefix string `json:\"prefix,omitempty\" description:\"An optional prefix to add to the echoed text.\"` // Use omitempty for optional } // Example: Handler for the \"echo\" tool using schema.HandleArgs func handleEchoTool(ctx context.Context, progressToken *protocol.ProgressToken, arguments any) (content []protocol.Content, isError bool) { // Use schema.HandleArgs to parse and validate arguments against the EchoArgs struct. // It automatically handles type checking, required fields, and generates error content. args, errContent, isErr := schema.HandleArgs[EchoArgs](arguments) if isErr { log.Printf(\"Error handling echo args: %v\", errContent) return errContent, true // Return the error content from HandleArgs } // If parsing succeeded, 'args' is a populated EchoArgs struct. log.Printf(\"Executing echo tool with input: '%s', prefix: '%s'\", args.Input, args.Prefix) // Construct the result message resultText := args.Prefix + args.Input // Return the result as TextContent result := []protocol.Content{ protocol.TextContent{ Type: \"text\", // Always specify the content type Text: resultText, }, } return result, false // Return false for isError on success } ","3-register-the-tool-with-the-server#3. Register the Tool with the Server":"Finally, use the RegisterTool method on your server.Server instance before running the server. Pass the protocol.Tool definition and the corresponding handler function.\npackage main import ( \"context\" \"log\" \"os\" \"github.com/localrivet/gomcp/protocol\" \"github.com/localrivet/gomcp/server\" \"github.com/localrivet/gomcp/util/schema\" ) // Assume echoTool definition (protocol.Tool) and // handleEchoTool (server.ToolHandlerFunc) are defined as above. func main() { // Configure logger log.SetOutput(os.Stderr) log.SetFlags(log.Ltime | log.Lshortfile) // Create the server instance srv := server.NewServer(\"MyToolServer\", server.ServerOptions{}) // Register the echo tool and its handler err := srv.RegisterTool(echoTool, handleEchoTool) if err != nil { log.Fatalf(\"Failed to register tool '%s': %v\", echoTool.Name, err) } log.Printf(\"Registered tool: %s\", echoTool.Name) // Start the server using stdio log.Println(\"Starting server on stdio...\") if err := server.ServeStdio(srv); err != nil { log.Fatalf(\"Server exited with error: %v\", err) } log.Println(\"Server stopped.\") } Now, when a client connects and sends a tools/call request for the “echo” tool with valid arguments, the handleEchoTool function will be executed, and its result will be sent back to the client. If the client sends a tools/list request, the echoTool definition will be included in the response."},"title":"Defining Server Tools"},"/docs/getting-started/":{"data":{"":"This guide will walk you through the initial steps to get up and running with the gomcp library.","installation#Installation":"First, you need to add the gomcp library to your Go project. Please follow the instructions on the Installation page.","next-steps#Next Steps":" Explore the guides on implementing a Server and Client. Learn how to define and register Tools. Check out the protocol details in the Protocols section: Messages Tools Resources Prompts ","prerequisites#Prerequisites":" Go: Ensure you have a recent version of Go installed (version 1.18 or later is recommended). You can download it from golang.org. ","your-first-mcp-server#Your First MCP Server":"Here’s a minimal example of how to create a basic MCP server using the stdio transport (communicating over standard input/output):\npackage main import ( \"log\" \"os\" \"github.com/localrivet/gomcp/server\" ) func main() { // Configure logger (optional, defaults to stderr) log.SetOutput(os.Stderr) log.SetFlags(log.Ltime | log.Lshortfile) log.Println(\"Starting Minimal MCP Server...\") // Create the core server instance // Provide a name and default options srv := server.NewServer(\"MyMinimalServer\", server.ServerOptions{}) // Register any tools here using srv.RegisterTool(...) // (See \"Defining Tools\" guide for details) // Start the server using the built-in stdio handler. // This blocks until the server exits (e.g., EOF on stdin or error). log.Println(\"Server setup complete. Listening on stdio...\") if err := server.ServeStdio(srv); err != nil { log.Fatalf(\"Server exited with error: %v\", err) } log.Println(\"Server shutdown complete.\") } To run this:\nSave the code as main.go. Run go mod init my-simple-server (if you haven’t already initialized a module). Run go mod tidy to fetch dependencies. Run go run main.go. The server will now listen for MCP JSON-RPC messages on standard input and send responses/notifications to standard output."},"title":"Getting Started"},"/docs/installation/":{"data":{"":"To use the gomcp library in your Go project, you can add it as a dependency using go get:\ngo get github.com/localrivet/gomcp Then, import it in your Go code:\nimport ( \"github.com/localrivet/gomcp/client\" // For building clients \"github.com/localrivet/gomcp/server\" // For building servers \"github.com/localrivet/gomcp/protocol\" // For message types // ... and specific transport packages as needed ) "},"title":"Installation"},"/docs/protocols/":{"data":{"":"This section details the specific messages and structures defined by the Model Context Protocol (MCP) as implemented by this library."},"title":"Protocols"},"/docs/protocols/protocol_messages/":{"data":{"":"This document describes the core JSON-RPC messages used in the Model Context Protocol (MCP).","notification-messages#Notification Messages":"initialized Sent from the client to the server after the client has received and processed the initialize result, indicating readiness.\nParameters (InitializedNotificationParams):\n(None) - The params object is empty. notifications/message Sent from the server to the client to provide a log message. This is typically used when the server’s logging capabilities are enabled.\nParameters (LoggingMessageParams):\nlevel (string, required): The severity level of the log message (\"error\", \"warn\", \"info\", \"debug\", \"trace\"). message (string, required): The log message content. $/cancelled Sent from the client to the server to indicate that a previously sent request should be cancelled.\nParameters (CancelledParams):\nid (integer | string, required): The ID of the request to be cancelled. $/progress Sent from the server to the client to report progress on a long-running operation initiated by a request.\nParameters (ProgressParams):\ntoken (string, required): The progress token associated with the request. value (any, required): The progress payload, specific to the operation being reported. notifications/roots/list_changed Sent from the client to the server when the list of available roots has changed.\nParameters (RootsListChangedParams):\n(None) - The params object is empty. notifications/tools/list_changed Sent from the server to the client when the list of available tools has changed.\nParameters (ToolsListChangedParams):\n(None) - The params object is empty. notifications/resources/list_changed Sent from the server to the client when the list of available resources has changed.\nParameters (ResourcesListChangedParams):\n(None) - The params object is empty. notifications/prompts/list_changed Sent from the server to the client when the list of available prompts has changed.\nParameters (PromptsListChangedParams):\n(None) - The params object is empty. (Other notification message details will go here)","request-messages#Request Messages":"initialize Sent from the client to the server to initiate the connection and exchange capabilities.\nParameters (InitializeRequestParams):\nprotocolVersion (string, required): The protocol version the client supports. capabilities (object, required): The capabilities the client supports (ClientCapabilities). clientInfo (object, required): Information about the client implementation (Implementation). trace (string, optional): Trace setting (‘off’, ‘messages’, ‘verbose’). workspaceFolders (array, optional): Workspace folders opened by the client (WorkspaceFolder[]). Result (InitializeResult): See Response Messages section.\nlogging/set_level Sent from the client to the server to request a change in the server’s logging verbosity.\nParameters (SetLevelRequestParams):\nlevel (string, required): The desired logging level (\"error\", \"warn\", \"info\", \"debug\", \"trace\"). Result:\n(None) - A successful response has an empty result. sampling/create_message Sent from the client to the server to request a model-generated message based on a provided context.\nParameters (CreateMessageRequestParams):\ncontext (array, required): A list of messages (SamplingMessage[]) providing the conversation history or context. Each message has role (string), content (array of Content objects), and optional name (string). preferences (object, optional): Desired model characteristics (ModelPreferences), including modelUri, temperature, topP, topK. Result (CreateMessageResult): See Response Messages section.\nroots/list Sent from the server to the client to request the list of available root contexts (e.g., workspace folders, open files).\nParameters (ListRootsRequestParams):\n(None) - The params object is currently empty. Result (ListRootsResult): See Response Messages section.\n(Other request message details will go here)","response-messages#Response Messages":"initialize (Result) The successful response to an initialize request.\nPayload (InitializeResult):\nprotocolVersion (string, required): The protocol version the server supports. capabilities (object, required): The capabilities the server supports (ServerCapabilities). serverInfo (object, required): Information about the server implementation (Implementation). instructions (string, optional): Optional instructions for the client after initialization. sampling/create_message (Result) The successful response to a sampling/create_message request.\nPayload (CreateMessageResult):\nmessage (object, required): The generated message from the model (SamplingMessage). modelHint (object, optional): Information about the model used (ModelHint), including modelUri, inputTokens, outputTokens, finishReason. roots/list (Result) The successful response to a roots/list request.\nPayload (ListRootsResult):\nroots (array, required): A list of root contexts (Root[]) available on the client. Each root has uri, optional kind, title, description, and metadata. (Other response message details will go here)"},"title":"Protocol Messages"},"/docs/protocols/protocol_prompts/":{"data":{"":"","notification-messages#Notification Messages":"notifications/prompts/list_changed Sent from the server to the client when the set of available prompts has changed (e.g., prompts added or removed). The client should typically re-fetch the prompt list using prompts/list.\nParameters (PromptsListChangedParams):\n(None) - The params object is empty. ","prompt-definition-prompt#Prompt Definition (\u003ccode\u003ePrompt\u003c/code\u003e)":"MCP servers can expose named prompts, which represent pre-defined instructions or templates that clients can utilize, often in conjunction with sampling requests. This document describes the protocol messages related to prompt discovery.\nPrompt Definition (Prompt) Represents a named prompt template provided by the server.\nuri (string, required): A unique identifier for the prompt. title (string, optional): A short, human-readable title. description (string, optional): A longer description of the prompt’s purpose. arguments (array, optional): A list of arguments (PromptArgument[]) that can be used to customize the prompt template. Each argument has: name (string, required) description (string, optional) type (string, required): e.g., “string”, “number”, “boolean”. required (boolean, optional) messages (array, required): The sequence of messages (PromptMessage[]) that make up the prompt template. Each message has: role (string, required): e.g., “system”, “user”, “assistant”. content (array, required): The content parts (Content[]) for the message. Content within prompts often includes template variables (syntax not defined by MCP core). metadata (object, optional): Additional arbitrary key-value pairs. ","request-messages#Request Messages":"prompts/list Sent from the client to the server to retrieve a list of available prompts, potentially filtered. Supports pagination.\nParameters (ListPromptsRequestParams):\nfilter (object, optional): Criteria to filter the prompts (specific filter structure not defined by the core protocol). cursor (string, optional): A cursor from a previous response to fetch the next page. prompts/get Sent from the client to the server to retrieve a specific prompt definition, potentially resolving template arguments.\nParameters (GetPromptRequestParams):\nuri (string, required): The URI of the prompt to retrieve. arguments (object, optional): Values for the prompt’s arguments, used for server-side template resolution if supported. ","response-messages#Response Messages":"prompts/list (Result) The successful response to a prompts/list request.\nPayload (ListPromptsResult):\nprompts (array, required): A list of prompts (Prompt[]) matching the filter criteria for the current page. nextCursor (string, optional): A cursor for fetching the next page. Omitted if this is the last page. prompts/get (Result) The successful response to a prompts/get request.\nPayload (GetPromptResult):\nprompt (object, required): The requested Prompt definition. If arguments were provided in the request and the server supports template resolution, the messages content may be resolved. "},"title":"Protocol Prompts"},"/docs/protocols/protocol_resources/":{"data":{"":"","notification-messages#Notification Messages":"notifications/resources/list_changed Sent from the server to the client when the set of available resources changes (e.g., resources added or removed). The client should typically re-fetch the resource list using resources/list.\nParameters (ResourcesListChangedParams):\n(None) - The params object is empty. notifications/resources/content_changed Sent from the server to the client when the content (and thus version) of a subscribed resource has changed.\nParameters (ResourceUpdatedParams):\nresource (object, required): The updated Resource object, containing the new version and potentially other changed metadata. The client should typically use resources/get to fetch the new content if needed. ","request-messages#Request Messages":"resources/list Sent from the client to the server to retrieve a list of available resources, potentially filtered. Supports pagination.\nParameters (ListResourcesRequestParams):\nfilter (object, optional): Criteria to filter the resources (specific filter structure not defined by the core protocol). cursor (string, optional): A cursor from a previous response to fetch the next page. resources/get (Corresponds to resources/read in Go code) Sent from the client to the server to retrieve the content of a specific resource.\nParameters (ReadResourceRequestParams):\nuri (string, required): The URI of the resource to retrieve. version (string, optional): If provided, the server may return a “Not Modified” error if the resource version matches. resources/subscribe Sent from the client to the server to request notifications when the content of specific resources changes.\nParameters (SubscribeResourceParams):\nuris (array of strings, required): A list of resource URIs to subscribe to. resources/unsubscribe Sent from the client to the server to stop receiving notifications for specific resources.\nParameters (UnsubscribeResourceParams):\nuris (array of strings, required): A list of resource URIs to unsubscribe from. ","resource-definition-resource#Resource Definition (\u003ccode\u003eResource\u003c/code\u003e)":"MCP servers can expose resources, which represent data sources that clients can access or subscribe to. This document describes the protocol messages related to resource discovery and access.\nResource Definition (Resource) Represents a data source provided by the server.\nuri (string, required): A unique identifier for the resource (e.g., file:///path/to/file, api://service/endpoint). kind (string, optional): A category or type hint for the resource (e.g., “file”, “api_spec”, “database_table”). title (string, optional): A short, human-readable title for the resource. description (string, optional): A longer description of the resource. version (string, optional): An opaque string representing the current version of the resource content. This should change whenever the content changes. metadata (object, optional): Additional arbitrary key-value pairs associated with the resource. ","response-messages#Response Messages":"resources/list (Result) The successful response to a resources/list request.\nPayload (ListResourcesResult):\nresources (array, required): A list of resources (Resource[]) matching the filter criteria for the current page. nextCursor (string, optional): A cursor for fetching the next page. Omitted if this is the last page. resources/get (Result - Corresponds to resources/read in Go code) The successful response to a resources/get request.\nPayload (ReadResourceResult):\nresource (object, required): The Resource object containing metadata (including the current version). contents (object, required): The actual content of the resource (ResourceContents). This will be either: TextResourceContents: Contains contentType (string) and content (string). BlobResourceContents: Contains contentType (string) and blob (string, base64 encoded). resources/subscribe (Result) The successful response to a resources/subscribe request.\nPayload (SubscribeResourceResult):\n(None) - The result object is currently empty upon success. resources/unsubscribe (Result) The successful response to an resources/unsubscribe request.\nPayload (UnsubscribeResourceResult):\n(None) - The result object is currently empty upon success. "},"title":"Protocol Resources"},"/docs/protocols/protocol_tools/":{"data":{"":"","notification-messages#Notification Messages":"notifications/tools/list_changed Sent from the server to the client when the set of available tools has changed (e.g., tools added or removed). The client should typically re-fetch the tool list using tools/list.\nParameters (ToolsListChangedParams):\n(None) - The params object is empty. ","request-messages#Request Messages":"tools/list Sent from the client to the server to retrieve the list of available tools. Supports pagination.\nParameters (ListToolsRequestParams):\ncursor (string, optional): A cursor returned from a previous tools/list response to fetch the next page of results. tools/call Sent from the client to the server to execute a specific tool with provided arguments.\nParameters (CallToolParams):\nname (string, required): The name of the tool to execute. arguments (object, optional): A map containing the arguments for the tool, conforming to the tool’s inputSchema. _meta (object, optional): Metadata associated with the request (RequestMeta), potentially including a progressToken. ","response-messages#Response Messages":"tools/list (Result) The successful response to a tools/list request.\nPayload (ListToolsResult):\ntools (array, required): A list of available tools (Tool[]). nextCursor (string, optional): A cursor to use in a subsequent tools/list request to fetch the next page of results. If omitted, there are no more tools. tools/call (Result) The successful response to a tools/call request.\nPayload (CallToolResult):\ncontent (array, required): The result of the tool execution, represented as an array of Content objects (e.g., TextContent, ImageContent). isError (boolean, optional): If true, indicates the content represents an error message rather than a successful result. _meta (object, optional): Metadata associated with the response (RequestMeta). ","tool-definition-tool#Tool Definition (\u003ccode\u003eTool\u003c/code\u003e)":"MCP servers can expose tools that clients can execute. This document describes the protocol messages related to tool discovery and execution.\nTool Definition (Tool) Represents a tool offered by the server.\nname (string, required): The unique identifier for the tool. description (string, optional): A human-readable description of what the tool does. inputSchema (object, required): A JSON Schema (ToolInputSchema) defining the expected arguments for the tool. type (string, required): Typically “object”. properties (object, optional): A map where keys are argument names and values are PropertyDetail objects describing the argument (type, description, enum, format). required (array, optional): A list of required argument names (strings). annotations (object, optional): Optional hints about the tool’s behavior (ToolAnnotations). title (string, optional): Human-readable title. readOnlyHint (boolean, optional): Indicates if the tool only reads data. destructiveHint (boolean, optional): Indicates if the tool might modify or delete data. idempotentHint (boolean, optional): Indicates if calling the tool multiple times with the same arguments has the same effect as calling it once. openWorldHint (boolean, optional): Indicates if the tool interacts with external systems or the real world. "},"title":"Protocol Tools"},"/examples/":{"data":{"":"This section contains runnable examples demonstrating various features and use cases of the gomcp library.\nYou can find the full source code for these and more complex examples in the /examples directory of the repository.","basic-stdio-server#Basic Stdio Server":"This example sets up a minimal server communicating over standard input/output.\npackage main import ( \"log\" \"os\" \"github.com/localrivet/gomcp/server\" \"github.com/localrivet/gomcp/transport/stdio\" \"github.com/localrivet/gomcp/types\" ) func main() { serverInfo := types.Implementation{Name: \"stdio-server\", Version: \"0.1.0\"} opts := server.NewServerOptions(serverInfo) srv := server.NewServer(opts) transport := stdio.NewStdioTransport(os.Stdin, os.Stdout, nil) log.Println(\"Starting stdio MCP server...\") if err := srv.Run(transport); err != nil { log.Fatalf(\"Server error: %v\", err) } log.Println(\"Server stopped.\") } (See examples/basic/stdio/main.go for the full runnable version)","registering-a-simple-tool#Registering a Simple Tool":"Here’s how you define and register a basic “echo” tool within your server setup.\npackage main import ( \"context\" \"fmt\" \"log\" \"os\" // ... other necessary imports from basic server example ... \"github.com/localrivet/gomcp/protocol\" \"github.com/localrivet/gomcp/server\" \"github.com/localrivet/gomcp/transport/stdio\" \"github.com/localrivet/gomcp/types\" ) // 1. Define the Tool Handler func handleEcho(ctx context.Context, args map[string]interface{}) ([]protocol.Content, error) { input, ok := args[\"text\"].(string) if !ok { return nil, fmt.Errorf(\"missing 'text' argument\") } return []protocol.Content{ protocol.TextContent{Type: \"text\", Text: \"Server Echo: \" + input}, }, nil } func main() { serverInfo := types.Implementation{Name: \"tool-server\", Version: \"0.1.0\"} opts := server.NewServerOptions(serverInfo) // Indicate tool support opts.Capabilities.Tools = \u0026protocol.ToolsCaps{} srv := server.NewServer(opts) // 2. Define the Tool Structure echoToolDef := protocol.Tool{ Name: \"echo\", Description: \"Echoes back the provided text.\", InputSchema: protocol.ToolInputSchema{ Type: \"object\", Properties: map[string]protocol.PropertyDetail{ \"text\": {Type: \"string\", Description: \"Text to echo\"}, }, Required: []string{\"text\"}, }, } // 3. Register the Tool if err := srv.RegisterTool(echoToolDef, handleEcho); err != nil { log.Fatalf(\"Failed to register tool: %v\", err) } log.Println(\"Registered 'echo' tool.\") transport := stdio.NewStdioTransport(os.Stdin, os.Stdout, nil) log.Println(\"Starting tool MCP server on stdio...\") if err := srv.Run(transport); err != nil { log.Fatalf(\"Server error: %v\", err) } log.Println(\"Server stopped.\") } (See examples/basic/tools/main.go for the full runnable version)\nExplore the other examples in the repository for more advanced scenarios involving different transports (HTTP/SSE, WebSockets), authentication, resource providers, and more."},"title":"Examples"},"/examples/auth/":{"data":{"":"","authenticated-server-examplesauthserver#Authenticated Server (\u003ccode\u003eexamples/auth/server\u003c/code\u003e)":"This page details the example found in the /examples/auth directory, demonstrating how to add a simple authentication layer to an MCP server, typically implemented as middleware in the transport layer.\nMCP itself doesn’t prescribe a specific authentication mechanism, allowing flexibility. This example uses a simple token check within HTTP middleware.\nAuthenticated Server (examples/auth/server) This example builds upon the HTTP+SSE transport, adding middleware to check for a valid Authorization header on incoming HTTP requests (both for the /message POSTs and the initial /events SSE connection).\nKey parts:\npackage main import ( \"fmt\" // Added for root handler \"log\" \"net/http\" \"strings\" // ... other imports: server, protocol, types, sse ... ) // Simple authentication middleware func authMiddleware(next http.Handler) http.Handler { return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) { authToken := r.Header.Get(\"Authorization\") // In a real app, validate the token properly! // This is a placeholder check. expectedToken := \"Bearer my-secret-token\" if authToken != expectedToken { log.Printf(\"Auth failed for %s: Invalid token '%s'\", r.URL.Path, authToken) http.Error(w, \"Unauthorized\", http.StatusUnauthorized) return // Stop processing if auth fails } log.Printf(\"Auth successful for %s\", r.URL.Path) next.ServeHTTP(w, r) // Call the next handler if auth succeeds }) } func main() { // 1. Setup MCP Server (as usual) serverInfo := types.Implementation{Name: \"auth-server\", Version: \"0.1.0\"} opts := server.NewServerOptions(serverInfo) srv := server.NewServer(opts) // Register tools, etc. // 2. Create SSE Transport Server sseServer := sse.NewServer(srv, opts.Logger) // 3. Setup HTTP Handlers mux := http.NewServeMux() // Apply middleware *only* to the MCP handlers authedEventsHandler := authMiddleware(http.HandlerFunc(sseServer.HTTPHandler)) authedMessageHandler := authMiddleware(http.HandlerFunc(srv.HTTPHandler)) mux.Handle(\"/events\", authedEventsHandler) mux.Handle(\"/message\", authedMessageHandler) // Add an unauthenticated root handler for testing mux.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, \"MCP Auth Server running. Use /events and /message with Authorization header.\") }) // 4. Start HTTP Server log.Println(\"Starting Auth MCP server on :8080...\") if err := http.ListenAndServe(\":8080\", mux); err != nil { log.Fatalf(\"HTTP server error: %v\", err) } } To Run:\nNavigate to examples/auth/server and run go run main.go. Use an MCP client (like the one in examples/auth/client) or tools like curl to interact: curl -H \"Authorization: Bearer my-secret-token\" http://localhost:8080/events (for SSE) curl -X POST -H \"Authorization: Bearer my-secret-token\" -H \"Content-Type: application/json\" -d '{\"jsonrpc\":\"2.0\", \"method\":\"initialize\", ...}' http://localhost:8080/message Requests without the correct Authorization: Bearer my-secret-token header will receive a 401 Unauthorized response."},"title":"Authentication"},"/examples/basic/":{"data":{"":"","basic-client-examplesbasicclient#Basic Client (\u003ccode\u003eexamples/basic/client\u003c/code\u003e)":"This page details the example found in the /examples/basic directory. It demonstrates a fundamental MCP server setup using the stdio transport, featuring multiple registered tools (echo, calculator, filesystem), and a corresponding client that interacts with these tools.\nBasic Multi-Tool Server (examples/basic/server) This example showcases a server communicating over standard input/output and managing several distinct tools.\nKey parts:\npackage main import ( \"context\" \"log\" \"os\" \"github.com/localrivet/gomcp/protocol\" \"github.com/localrivet/gomcp/server\" \"github.com/localrivet/gomcp/util/schema\" ) // Define arguments for the echo tool type EchoArgs struct { Message string `json:\"message\" description:\"The message to echo.\"` } // Handler for the echo tool func echoHandler(ctx context.Context, progressToken *protocol.ProgressToken, arguments any) (content []protocol.Content, isError bool) { args, errContent, isErr := schema.HandleArgs[EchoArgs](arguments) if isErr { log.Printf(\"Error handling echo args: %v\", errContent) return errContent, true } log.Printf(\"Executing echo tool with message: %s\", args.Message) // Note: The actual example prepends \"Echo: \" in its response return []protocol.Content{protocol.TextContent{Type: \"text\", Text: args.Message}}, false } // (Handlers for calculator and filesystem tools are also defined in the full example) func main() { log.SetOutput(os.Stderr) log.SetFlags(log.Ltime | log.Lshortfile) log.Println(\"Starting Basic Multi-Tool MCP Server...\") // Create the core server instance srv := server.NewServer(\"GoMultiToolServer\", server.ServerOptions{}) // Define the echo tool echoTool := protocol.Tool{ Name: \"echo\", Description: \"Echoes back the provided message.\", InputSchema: schema.FromStruct(EchoArgs{}), // Generate schema from struct } // Register the echo tool if err := srv.RegisterTool(echoTool, echoHandler); err != nil { log.Fatalf(\"Failed to register echo tool: %v\", err) } // (Calculator and Filesystem tools are also registered in the full example) log.Println(\"Server setup complete. Listening on stdio...\") // Start the server using the built-in stdio handler. // This blocks until the server exits (e.g., EOF on stdin or error). if err := server.ServeStdio(srv); err != nil { log.Fatalf(\"Server exited with error: %v\", err) } log.Println(\"Server shutdown complete.\") } Basic Client (examples/basic/client) The corresponding client connects to the server via stdio, lists the available tools, and then calls each tool (echo, calculator, filesystem) with various arguments to demonstrate interaction and error handling. See the examples/basic/client/main.go file for the full implementation.","basic-multi-tool-server-examplesbasicserver#Basic Multi-Tool Server (\u003ccode\u003eexamples/basic/server\u003c/code\u003e)":"","running-the-example#Running the Example":"The server and client are designed to be connected via standard input/output.\nNavigate to the main examples directory in your terminal.\nRun the following command to pipe the client’s output to the server’s input and vice-versa:\n(cd basic/server \u0026\u0026 go run .) | (cd basic/client \u0026\u0026 go run .) You will see log output from both the server and the client in your terminal, showing the handshake, tool listing, and results of each tool call."},"title":"Basic (Stdio Multi-Tool)"},"/examples/billing/":{"data":{"":"","billing-server-examplesbillingserver#Billing Server (\u003ccode\u003eexamples/billing/server\u003c/code\u003e)":"This page details the example found in the /examples/billing directory, demonstrating a conceptual approach to tracking usage or costs associated with MCP tool calls.\nMCP doesn’t define a billing protocol, so this example shows one possible implementation strategy, likely involving middleware or logic within tool handlers to record usage events.\nBilling Server (examples/billing/server) This example likely intercepts tool calls (perhaps using middleware similar to the auth example, or within the tool handlers themselves) to record usage information before or after the tool executes.\nConceptual Snippets (Illustrative - check main.go for actual implementation):\nMiddleware Approach:\n// Hypothetical middleware to track tool calls func billingMiddleware(srv *server.Server) func(http.Handler) http.Handler { return func(next http.Handler) http.Handler { return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) { // Attempt to decode the request to see if it's a tools/call // (This is complex as the body needs to be read and potentially replaced) // ... decode logic ... isToolCall := false // Assume decoding logic sets this toolName := \"\" // Assume decoding logic sets this clientID := \"\" // Assume auth middleware sets this if isToolCall { // Record usage before calling the actual handler log.Printf(\"BILLING: Recording usage for client '%s', tool '%s'\", clientID, toolName) // recordUsage(clientID, toolName, time.Now()) // Your billing logic } next.ServeHTTP(w, r) // Call the main MCP handler // Could also record after the call, potentially based on response status }) } } func main() { // ... setup srv, sseServer ... mux := http.NewServeMux() // Wrap the message handler with billing and auth middleware messageHandler := http.HandlerFunc(srv.HTTPHandler) // Order matters: auth first, then billing wrappedHandler := authMiddleware(billingMiddleware(srv)(messageHandler)) mux.Handle(\"/message\", wrappedHandler) mux.Handle(\"/events\", authMiddleware(http.HandlerFunc(sseServer.HTTPHandler))) // Auth SSE too // ... start server ... } Handler Approach:\n// Tool handler includes billing logic func handleBillableTool(ctx context.Context, args map[string]interface{}) ([]protocol.Content, error) { clientID := \"\" // Get client ID from context (if passed via middleware) toolName := \"billableTool\" // Record usage at the start log.Printf(\"BILLING: Recording usage for client '%s', tool '%s'\", clientID, toolName) // recordUsage(clientID, toolName, time.Now()) // --- Actual tool logic --- resultText := \"Executed billable tool.\" // --- End tool logic --- return []protocol.Content{protocol.TextContent{Type: \"text\", Text: resultText}}, nil } func main() { // ... setup srv ... // Register the tool with the billing-aware handler srv.RegisterTool(billableToolDef, handleBillableTool) // ... setup transport and run ... } To Run: Navigate to examples/billing/server and run go run main.go. Observe the server logs for billing messages when tools are called (requires a client like the one in examples/billing/client).\nNote: The actual implementation in examples/billing/server/main.go should be consulted for the precise mechanism used. These snippets illustrate common patterns. Implementing robust billing often involves integrating with external systems or databases."},"title":"Billing / Usage Tracking"},"/examples/cmd/":{"data":{"":"","cli-server-examplescmdserver#CLI Server (\u003ccode\u003eexamples/cmd/server\u003c/code\u003e)":"This page details the example found in the /examples/cmd directory, demonstrating how to build command-line interface (CLI) applications that function as MCP servers or clients.\nThis is useful for creating standalone tools that can be invoked from the terminal and communicate using MCP, often over the stdio transport.\nCLI Server (examples/cmd/server) This example likely uses the standard Go flag package or a library like Cobra to parse command-line arguments and then starts an MCP server (probably using stdio transport) based on those arguments.\nConceptual Snippets (Illustrative - check main.go for actual implementation):\npackage main import ( \"flag\" // Or \"github.com/spf13/cobra\" \"log\" \"os\" // ... other imports: server, protocol, types, stdio ... \"github.com/localrivet/gomcp/types\" // Added for types.Transport ) func main() { // --- Define Command-Line Flags --- // Example using standard 'flag' package port := flag.Int(\"port\", 0, \"Port to listen on (if using TCP/WebSocket transport, 0 for stdio)\") serverName := flag.String(\"name\", \"cli-server\", \"Name of the server\") // Add flags for tool definitions, config files, etc. flag.Parse() // Parse the flags // --- Setup MCP Server --- serverInfo := types.Implementation{Name: *serverName, Version: \"0.1.0\"} opts := server.NewServerOptions(serverInfo) // Configure capabilities based on flags... srv := server.NewServer(opts) // Register tools based on flags or config files... // --- Choose Transport Based on Flags --- var transport types.Transport if *port \u003e 0 { // Setup TCP or WebSocket transport on the specified port (example) // log.Printf(\"Starting TCP server on port %d\", *port) // transport = tcp.NewFactory(srv, opts.Logger).Listen(fmt.Sprintf(\":%d\", *port)) // Hypothetical log.Fatalf(\"TCP/WebSocket transport not fully implemented in this snippet\") } else { log.Println(\"Starting stdio MCP server...\") transport = stdio.NewStdioTransport(os.Stdin, os.Stdout, opts.Logger) } // --- Run the Server --- if err := srv.Run(transport); err != nil { log.Fatalf(\"Server error: %v\", err) } log.Println(\"Server stopped.\") } To Run:\nNavigate to examples/cmd/server. Build the binary: go build -o my-mcp-server Run it: ./my-mcp-server (Uses stdio transport by default) ./my-mcp-server -name \"My Custom Server\" (Overrides server name) (Add other flags as defined in the actual main.go) This pattern allows creating flexible MCP servers or clients whose behavior can be controlled via command-line arguments."},"title":"Command-Line (CLI)"},"/examples/configuration/":{"data":{"":"","configuration-server-examplesconfigurationserver#Configuration Server (\u003ccode\u003eexamples/configuration/server\u003c/code\u003e)":"This page details the example found in the /examples/configuration directory, demonstrating how to load server settings and tool definitions from external configuration files (JSON, TOML, or YAML) instead of defining them directly in code.\nThis approach allows for easier management and modification of server capabilities without recompiling the server binary.\nConfiguration Server (examples/configuration/server) This example uses the Viper library to read configuration files and then dynamically registers tools based on the loaded definitions.\nKey parts:\npackage main import ( \"context\" \"fmt\" \"log\" \"net/http\" \"strings\" \"github.com/localrivet/gomcp/protocol\" \"github.com/localrivet/gomcp/server\" \"github.com/localrivet/gomcp/transport/sse\" // Using SSE transport here \"github.com/localrivet/gomcp/types\" \"github.com/spf13/viper\" // For config loading ) // Generic handler for configured tools (example implementation) func handleConfiguredTool(toolName string) server.ToolHandlerFunc { return func(ctx context.Context, args map[string]interface{}) ([]protocol.Content, error) { log.Printf(\"Executing configured tool '%s' with args: %v\", toolName, args) // In a real scenario, dispatch to specific logic based on toolName responseText := fmt.Sprintf(\"Executed tool '%s'. Args: %v\", toolName, args) return []protocol.Content{protocol.TextContent{Type: \"text\", Text: responseText}}, nil } } func main() { // --- Load Configuration using Viper --- viper.SetConfigName(\"config\") // Name of config file (without extension) viper.AddConfigPath(\".\") // Look in the current directory viper.AddConfigPath(\"../\") // Look in the parent directory (where config.* files are) viper.AutomaticEnv() // Read in environment variables that match if err := viper.ReadInConfig(); err != nil { log.Fatalf(\"Error reading config file: %s\", err) } log.Printf(\"Using config file: %s\", viper.ConfigFileUsed()) // --- Setup MCP Server --- serverInfo := types.Implementation{Name: \"config-server\", Version: \"0.1.0\"} opts := server.NewServerOptions(serverInfo) opts.Capabilities.Tools = \u0026protocol.ToolsCaps{} // Enable tool capability srv := server.NewServer(opts) // --- Register Tools from Configuration --- // Assuming config structure like: // tools: // - name: tool1 // description: \"Description for tool1\" // inputSchema: { ... } // - name: tool2 // description: \"Description for tool2\" // inputSchema: { ... } var configuredTools []protocol.Tool if err := viper.UnmarshalKey(\"tools\", \u0026configuredTools); err != nil { log.Fatalf(\"Unable to decode tools from config: %v\", err) } for _, tool := range configuredTools { log.Printf(\"Registering tool from config: %s\", tool.Name) // Need a local copy for the closure localTool := tool if err := srv.RegisterTool(localTool, handleConfiguredTool(localTool.Name)); err != nil { log.Printf(\"WARN: Failed to register tool '%s': %v\", localTool.Name, err) } } // --- Setup Transport (SSE+HTTP) and Run --- sseServer := sse.NewServer(srv, opts.Logger) mux := http.NewServeMux() mux.HandleFunc(\"/events\", sseServer.HTTPHandler) mux.HandleFunc(\"/message\", srv.HTTPHandler) log.Println(\"Starting config MCP server on :8080...\") if err := http.ListenAndServe(\":8080\", mux); err != nil { log.Fatalf(\"HTTP server error: %v\", err) } } To Run:\nNavigate to examples/configuration/server. Ensure one of the config files (../config.json, ../config.toml, ../config.yaml) exists in the parent directory. Run go run main.go. Viper will automatically detect and load the configuration file. This example demonstrates a powerful pattern for managing complex server setups where capabilities might change frequently or need to be defined outside the main application code."},"title":"Configuration Loading"},"/examples/http/beego/":{"data":{"":"","beego-server-exampleshttpbeego#Beego Server (\u003ccode\u003eexamples/http/beego\u003c/code\u003e)":"This page details the example found in /examples/http/beego, demonstrating how to integrate the HTTP+SSE transport with the Beego web framework.\nBeego Server (examples/http/beego) This example shows how to mount the sse.Server and server.Server HTTP handlers onto a Beego application.\nKey parts:\npackage main import ( \"log\" \"net/http\" \"github.com/beego/beego/v2/server/web\" // ... other imports: server, protocol, types, sse ... ) func main() { // 1. Setup MCP Server (as usual) serverInfo := types.Implementation{Name: \"beego-http-server\", Version: \"0.1.0\"} opts := server.NewServerOptions(serverInfo) srv := server.NewServer(opts) // Register tools, etc. // 2. Create SSE Transport Server sseServer := sse.NewServer(srv, opts.Logger) // 3. Setup Beego Handlers // Beego typically uses controllers, but we can adapt http.Handlers web.Handler(\"/events\", http.HandlerFunc(sseServer.HTTPHandler)) web.Handler(\"/message\", http.HandlerFunc(srv.HTTPHandler)) // Add a root handler for testing web.Get(\"/\", func(ctx *context.Context) { // Note: Beego v2 context might differ ctx.WriteString(\"Beego MCP Server running. Use /events and /message.\") }) // 4. Start Beego Server log.Println(\"Starting Beego HTTP+SSE MCP server on :8080...\") // Beego uses web.Run() to start the server web.Run(\":8080\") // Note: Unlike http.ListenAndServe, web.Run() might not return errors in the same way. // Check Beego docs for production error handling. } To Run: Navigate to examples/http/beego and run go run main.go. Clients connect as described in the net/http example (SSE to /events, POST to /message).\nBeego’s web.Handler function allows registering standard http.Handler interfaces directly for specific routes and methods."},"title":"Beego"},"/examples/http/chi/":{"data":{"":"","chi-server-exampleshttpchi#Chi Server (\u003ccode\u003eexamples/http/chi\u003c/code\u003e)":"This page details the example found in /examples/http/chi, demonstrating how to integrate the HTTP+SSE transport with the Chi router.\nChi Server (examples/http/chi) This example shows how to mount the sse.Server and server.Server HTTP handlers onto a Chi router.\nKey parts:\npackage main import ( \"log\" \"net/http\" \"github.com/go-chi/chi/v5\" \"github.com/go-chi/chi/v5/middleware\" // ... other imports: server, protocol, types, sse ... ) func main() { // 1. Setup MCP Server (as usual) serverInfo := types.Implementation{Name: \"chi-http-server\", Version: \"0.1.0\"} opts := server.NewServerOptions(serverInfo) srv := server.NewServer(opts) // Register tools, etc. // 2. Create SSE Transport Server sseServer := sse.NewServer(srv, opts.Logger) // 3. Setup Chi Router r := chi.NewRouter() r.Use(middleware.Logger) // Example middleware // Mount handlers directly as they satisfy http.Handler r.Get(\"/events\", sseServer.HTTPHandler) r.Post(\"/message\", srv.HTTPHandler) // Add a root handler for testing r.Get(\"/\", func(w http.ResponseWriter, r *http.Request) { w.Write([]byte(\"Chi MCP Server running. Use /events and /message.\")) }) // 4. Start Chi Server log.Println(\"Starting Chi HTTP+SSE MCP server on :8080...\") if err := http.ListenAndServe(\":8080\", r); err != nil { log.Fatalf(\"Chi server error: %v\", err) } } To Run: Navigate to examples/http/chi and run go run main.go. Clients connect as described in the net/http example (SSE to /events, POST to /message).\nSince the gomcp handlers (sseServer.HTTPHandler and srv.HTTPHandler) implement the standard http.Handler interface, they can be mounted directly onto the Chi router using methods like r.Get and r.Post."},"title":"Chi"},"/examples/http/echo/":{"data":{"":"","echo-server-exampleshttpecho#Echo Server (\u003ccode\u003eexamples/http/echo\u003c/code\u003e)":"This page details the example found in /examples/http/echo, demonstrating how to integrate the HTTP+SSE transport with the Echo web framework.\nEcho Server (examples/http/echo) This example shows how to mount the sse.Server and server.Server HTTP handlers onto an Echo router.\nKey parts:\npackage main import ( \"log\" \"net/http\" \"github.com/labstack/echo/v4\" \"github.com/labstack/echo/v4/middleware\" // ... other imports: server, protocol, types, sse ... ) func main() { // 1. Setup MCP Server (as usual) serverInfo := types.Implementation{Name: \"echo-http-server\", Version: \"0.1.0\"} opts := server.NewServerOptions(serverInfo) srv := server.NewServer(opts) // Register tools, etc. // 2. Create SSE Transport Server sseServer := sse.NewServer(srv, opts.Logger) // 3. Setup Echo Instance e := echo.New() e.Use(middleware.Logger()) // Example middleware // Wrap the MCP handlers for Echo // Echo expects handlers of type echo.HandlerFunc eventsHandler := echo.WrapHandler(http.HandlerFunc(sseServer.HTTPHandler)) messageHandler := echo.WrapHandler(http.HandlerFunc(srv.HTTPHandler)) // Mount handlers e.GET(\"/events\", eventsHandler) e.POST(\"/message\", messageHandler) // Add a root handler for testing e.GET(\"/\", func(c echo.Context) error { return c.String(http.StatusOK, \"Echo MCP Server running. Use /events and /message.\") }) // 4. Start Echo Server log.Println(\"Starting Echo HTTP+SSE MCP server on :8080...\") if err := e.Start(\":8080\"); err != nil \u0026\u0026 err != http.ErrServerClosed { log.Fatalf(\"Echo server error: %v\", err) } } To Run: Navigate to examples/http/echo and run go run main.go. Clients connect as described in the net/http example (SSE to /events, POST to /message).\nSimilar to the Gin example, the key is using echo.WrapHandler to adapt the standard http.HandlerFunc provided by gomcp to the echo.HandlerFunc expected by the Echo framework."},"title":"Echo"},"/examples/http/fiber/":{"data":{"":"","fiber-server-exampleshttpfiber#Fiber Server (\u003ccode\u003eexamples/http/fiber\u003c/code\u003e)":"This page details the example found in /examples/http/fiber, demonstrating how to integrate the HTTP+SSE transport with the Fiber web framework.\nFiber Server (examples/http/fiber) This example shows how to mount the sse.Server and server.Server HTTP handlers onto a Fiber app, using the adaptor package to convert standard http.Handlers.\nKey parts:\npackage main import ( \"log\" \"net/http\" \"github.com/gofiber/fiber/v2\" \"github.com/gofiber/fiber/v2/middleware/adaptor\" // For converting http.Handler \"github.com/gofiber/fiber/v2/middleware/logger\" // ... other imports: server, protocol, types, sse ... ) func main() { // 1. Setup MCP Server (as usual) serverInfo := types.Implementation{Name: \"fiber-http-server\", Version: \"0.1.0\"} opts := server.NewServerOptions(serverInfo) srv := server.NewServer(opts) // Register tools, etc. // 2. Create SSE Transport Server sseServer := sse.NewServer(srv, opts.Logger) // 3. Setup Fiber App app := fiber.New() app.Use(logger.New()) // Example middleware // Convert the standard http.HandlerFunc to Fiber handlers eventsHandler := adaptor.HTTPHandlerFunc(sseServer.HTTPHandler) messageHandler := adaptor.HTTPHandlerFunc(srv.HTTPHandler) // Mount handlers app.Get(\"/events\", eventsHandler) app.Post(\"/message\", messageHandler) // Add a root handler for testing app.Get(\"/\", func(c *fiber.Ctx) error { return c.SendString(\"Fiber MCP Server running. Use /events and /message.\") }) // 4. Start Fiber Server log.Println(\"Starting Fiber HTTP+SSE MCP server on :8080...\") if err := app.Listen(\":8080\"); err != nil { log.Fatalf(\"Fiber server error: %v\", err) } } To Run: Navigate to examples/http/fiber and run go run main.go. Clients connect as described in the net/http example (SSE to /events, POST to /message).\nThe key here is using adaptor.HTTPHandlerFunc from the Fiber middleware package to wrap the standard http.HandlerFunc provided by gomcp so it can be used with Fiber’s routing methods."},"title":"Fiber"},"/examples/http/gin/":{"data":{"":"","gin-server-exampleshttpgin#Gin Server (\u003ccode\u003eexamples/http/gin\u003c/code\u003e)":"This page details the example found in /examples/http/gin, demonstrating how to integrate the HTTP+SSE transport with the Gin web framework.\nGin Server (examples/http/gin) This example shows how to mount the sse.Server and server.Server HTTP handlers onto a Gin router.\nKey parts:\npackage main import ( \"log\" \"net/http\" \"github.com/gin-gonic/gin\" // ... other imports: server, protocol, types, sse ... ) func main() { // 1. Setup MCP Server (as usual) serverInfo := types.Implementation{Name: \"gin-http-server\", Version: \"0.1.0\"} opts := server.NewServerOptions(serverInfo) srv := server.NewServer(opts) // Register tools, etc. // 2. Create SSE Transport Server sseServer := sse.NewServer(srv, opts.Logger) // 3. Setup Gin Router router := gin.Default() // Wrap the MCP handlers for Gin // Gin expects handlers of type gin.HandlerFunc eventsHandler := gin.WrapH(http.HandlerFunc(sseServer.HTTPHandler)) messageHandler := gin.WrapH(http.HandlerFunc(srv.HTTPHandler)) // Mount handlers router.GET(\"/events\", eventsHandler) router.POST(\"/message\", messageHandler) // Add a root handler for testing router.GET(\"/\", func(c *gin.Context) { c.String(http.StatusOK, \"Gin MCP Server running. Use /events and /message.\") }) // 4. Start Gin Server log.Println(\"Starting Gin HTTP+SSE MCP server on :8080...\") if err := router.Run(\":8080\"); err != nil { log.Fatalf(\"Gin server error: %v\", err) } } To Run: Navigate to examples/http/gin and run go run main.go. Clients connect as described in the net/http example (SSE to /events, POST to /message).\nThe key difference is using gin.WrapH to adapt the standard http.HandlerFunc provided by the gomcp library to the gin.HandlerFunc expected by the Gin router."},"title":"Gin"},"/examples/http/go-zero/":{"data":{"":"","go-zero-server-exampleshttpgo-zero#go-zero Server (\u003ccode\u003eexamples/http/go-zero\u003c/code\u003e)":"This page details the example found in /examples/http/go-zero, demonstrating how to integrate the HTTP+SSE transport with the go-zero web framework.\ngo-zero Server (examples/http/go-zero) This example shows how to mount the sse.Server and server.Server HTTP handlers onto a go-zero rest.Server.\nKey parts:\npackage main import ( \"flag\" \"log\" \"net/http\" \"github.com/zeromicro/go-zero/core/conf\" \"github.com/zeromicro/go-zero/rest\" // ... other imports: server, protocol, types, sse ... ) // Define go-zero config structure (if needed, often minimal for this) type Config struct { rest.RestConf } func main() { // --- go-zero Config Loading --- var configFile = flag.String(\"f\", \"etc/config.yaml\", \"the config file\") // go-zero convention flag.Parse() var c Config conf.MustLoad(*configFile, \u0026c) // Load config (might just contain RestConf) // --- Setup MCP Server --- serverInfo := types.Implementation{Name: \"go-zero-http-server\", Version: \"0.1.0\"} opts := server.NewServerOptions(serverInfo) srv := server.NewServer(opts) // Register tools, etc. // --- Create SSE Transport Server --- sseServer := sse.NewServer(srv, opts.Logger) // --- Setup go-zero Server and Routes --- engine := rest.MustNewServer(c.RestConf) defer engine.Stop() // Mount standard http.Handlers directly engine.AddRoute(rest.Route{ Method: http.MethodGet, Path: \"/events\", Handler: http.HandlerFunc(sseServer.HTTPHandler), }) engine.AddRoute(rest.Route{ Method: http.MethodPost, Path: \"/message\", Handler: http.HandlerFunc(srv.HTTPHandler), }) // Add a root handler for testing engine.AddRoute(rest.Route{ Method: http.MethodGet, Path: \"/\", Handler: func(w http.ResponseWriter, r *http.Request) { w.Write([]byte(\"go-zero MCP Server running. Use /events and /message.\")) }, }) // --- Start go-zero Server --- log.Printf(\"Starting go-zero HTTP+SSE MCP server on %s:%d...\", c.Host, c.Port) engine.Start() // Blocks until interrupted } (Note: This assumes a minimal etc/config.yaml exists for go-zero’s rest.RestConf, e.g., specifying Host and Port)\nTo Run: Navigate to examples/http/go-zero and run go run main.go -f etc/config.yaml. Clients connect as described in the net/http example (SSE to /events, POST to /message).\ngo-zero’s rest.Server allows adding routes with standard http.HandlerFunc handlers, making integration straightforward."},"title":"go-zero"},"/examples/http/gorillamux/":{"data":{"":"","gorilla-mux-server-exampleshttpgorillamux#Gorilla Mux Server (\u003ccode\u003eexamples/http/gorillamux\u003c/code\u003e)":"This page details the example found in /examples/http/gorillamux, demonstrating how to integrate the HTTP+SSE transport with the Gorilla Mux router.\nGorilla Mux Server (examples/http/gorillamux) This example shows how to mount the sse.Server and server.Server HTTP handlers onto a Gorilla Mux router.\nKey parts:\npackage main import ( \"log\" \"net/http\" \"github.com/gorilla/mux\" // ... other imports: server, protocol, types, sse ... ) func main() { // 1. Setup MCP Server (as usual) serverInfo := types.Implementation{Name: \"gorillamux-http-server\", Version: \"0.1.0\"} opts := server.NewServerOptions(serverInfo) srv := server.NewServer(opts) // Register tools, etc. // 2. Create SSE Transport Server sseServer := sse.NewServer(srv, opts.Logger) // 3. Setup Gorilla Mux Router r := mux.NewRouter() // Mount handlers directly as they satisfy http.Handler r.HandleFunc(\"/events\", sseServer.HTTPHandler).Methods(\"GET\") r.HandleFunc(\"/message\", srv.HTTPHandler).Methods(\"POST\") // Add a root handler for testing r.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) { w.Write([]byte(\"Gorilla Mux MCP Server running. Use /events and /message.\")) }).Methods(\"GET\") // 4. Start Server with Mux Router log.Println(\"Starting Gorilla Mux HTTP+SSE MCP server on :8080...\") if err := http.ListenAndServe(\":8080\", r); err != nil { log.Fatalf(\"HTTP server error: %v\", err) } } To Run: Navigate to examples/http/gorillamux and run go run main.go. Clients connect as described in the net/http example (SSE to /events, POST to /message).\nSimilar to Chi, the standard http.HandlerFunc provided by gomcp can be used directly with Gorilla Mux’s HandleFunc method, specifying the appropriate HTTP method (GET for SSE, POST for messages)."},"title":"Gorilla Mux"},"/examples/http/httprouter/":{"data":{"":"","httprouter-server-exampleshttphttprouter#HttpRouter Server (\u003ccode\u003eexamples/http/httprouter\u003c/code\u003e)":"This page details the example found in /examples/http/httprouter, demonstrating how to integrate the HTTP+SSE transport with the HttpRouter router.\nHttpRouter Server (examples/http/httprouter) This example shows how to mount the sse.Server and server.Server HTTP handlers onto an HttpRouter instance.\nKey parts:\npackage main import ( \"log\" \"net/http\" \"github.com/julienschmidt/httprouter\" // ... other imports: server, protocol, types, sse ... ) // Helper function to adapt http.Handler to httprouter.Handle func wrapHandler(h http.Handler) httprouter.Handle { return func(w http.ResponseWriter, r *http.Request, ps httprouter.Params) { h.ServeHTTP(w, r) } } func main() { // 1. Setup MCP Server (as usual) serverInfo := types.Implementation{Name: \"httprouter-http-server\", Version: \"0.1.0\"} opts := server.NewServerOptions(serverInfo) srv := server.NewServer(opts) // Register tools, etc. // 2. Create SSE Transport Server sseServer := sse.NewServer(srv, opts.Logger) // 3. Setup HttpRouter router := httprouter.New() // Wrap and mount handlers router.GET(\"/events\", wrapHandler(http.HandlerFunc(sseServer.HTTPHandler))) router.POST(\"/message\", wrapHandler(http.HandlerFunc(srv.HTTPHandler))) // Add a root handler for testing router.GET(\"/\", func(w http.ResponseWriter, r *http.Request, _ httprouter.Params) { w.Write([]byte(\"HttpRouter MCP Server running. Use /events and /message.\")) }) // 4. Start Server with HttpRouter log.Println(\"Starting HttpRouter HTTP+SSE MCP server on :8080...\") if err := http.ListenAndServe(\":8080\", router); err != nil { log.Fatalf(\"HTTP server error: %v\", err) } } To Run: Navigate to examples/http/httprouter and run go run main.go. Clients connect as described in the net/http example (SSE to /events, POST to /message).\nHttpRouter requires handlers of type httprouter.Handle. A simple wrapper function (wrapHandler in this example) is needed to adapt the standard http.Handler provided by gomcp to the required signature."},"title":"HttpRouter"},"/examples/http/iris/":{"data":{"":"","iris-server-exampleshttpiris#Iris Server (\u003ccode\u003eexamples/http/iris\u003c/code\u003e)":"This page details the example found in /examples/http/iris, demonstrating how to integrate the HTTP+SSE transport with the Iris web framework.\nIris Server (examples/http/iris) This example shows how to mount the sse.Server and server.Server HTTP handlers onto an Iris application.\nKey parts:\npackage main import ( \"log\" \"net/http\" \"github.com/kataras/iris/v12\" \"github.com/kataras/iris/v12/middleware/logger\" \"github.com/kataras/iris/v12/middleware/recover\" // ... other imports: server, protocol, types, sse ... ) func main() { // 1. Setup MCP Server (as usual) serverInfo := types.Implementation{Name: \"iris-http-server\", Version: \"0.1.0\"} opts := server.NewServerOptions(serverInfo) srv := server.NewServer(opts) // Register tools, etc. // 2. Create SSE Transport Server sseServer := sse.NewServer(srv, opts.Logger) // 3. Setup Iris App app := iris.New() app.Use(recover.New()) app.Use(logger.New()) // Wrap the standard http.HandlerFunc for Iris eventsHandler := iris.FromStd(http.HandlerFunc(sseServer.HTTPHandler)) messageHandler := iris.FromStd(http.HandlerFunc(srv.HTTPHandler)) // Mount handlers app.Get(\"/events\", eventsHandler) app.Post(\"/message\", messageHandler) // Add a root handler for testing app.Get(\"/\", func(ctx iris.Context) { ctx.WriteString(\"Iris MCP Server running. Use /events and /message.\") }) // 4. Start Iris Server log.Println(\"Starting Iris HTTP+SSE MCP server on :8080...\") // Use app.Listen for standard net/http server start err := app.Listen(\":8080\") if err != nil { log.Fatalf(\"Iris server error: %v\", err) } } To Run: Navigate to examples/http/iris and run go run main.go. Clients connect as described in the net/http example (SSE to /events, POST to /message).\nIris provides the iris.FromStd function to easily convert a standard http.Handler or http.HandlerFunc into a handler compatible with the Iris router."},"title":"Iris"},"/examples/http/nethttp/":{"data":{"":"","other-frameworks#Other Frameworks":"The /examples/http directory contains similar integrations for popular frameworks like Gin, Echo, Chi, Fiber, etc. The core principle remains the same:\nInitialize the server.Server. Initialize the sse.Server, passing the server.Server instance. Mount the sseServer.HTTPHandler to an endpoint for the event stream (e.g., /events). Mount the srv.HTTPHandler to an endpoint for receiving client messages (e.g., /message). Refer to the specific subdirectories for framework-specific integration details.","standard-library-nethttp-example-exampleshttpnethttp#Standard Library (\u003ccode\u003enet/http\u003c/code\u003e) Example (\u003ccode\u003eexamples/http/nethttp\u003c/code\u003e)":"This page details the examples found in the /examples/http directory, demonstrating how to set up an MCP server using the HTTP + Server-Sent Events (SSE) hybrid transport.\nThis transport uses:\nHTTP POST: For client-to-server messages (requests like tools/call, notifications like initialized). Server-Sent Events (SSE): For server-to-client messages (responses like initialize result, notifications like $/progress, server-sent requests). The transport/sse package provides an sse.Server that handles the transport logic. You typically integrate its handlers into your chosen Go web framework or the standard net/http library.\nStandard Library (net/http) Example (examples/http/nethttp) This example shows how to integrate the sse.Server with Go’s built-in net/http package.\nKey parts:\npackage main import ( \"log\" \"net/http\" // ... other imports: server, protocol, types ... \"github.com/localrivet/gomcp/transport/sse\" ) func main() { // 1. Setup MCP Server (like in basic examples) serverInfo := types.Implementation{Name: \"http-server\", Version: \"0.1.0\"} opts := server.NewServerOptions(serverInfo) // opts.Capabilities... // Set capabilities srv := server.NewServer(opts) // srv.RegisterTool(...) // Register tools, resources, etc. // 2. Create SSE Transport Server sseServer := sse.NewServer(srv, opts.Logger) // Pass the MCP server instance // 3. Setup HTTP Handlers mux := http.NewServeMux() // The SSE handler manages the persistent event stream mux.HandleFunc(\"/events\", sseServer.HTTPHandler) // The Message handler receives client POST requests mux.HandleFunc(\"/message\", srv.HTTPHandler) // Use the MCP server's handler // 4. Start HTTP Server log.Println(\"Starting HTTP+SSE MCP server on :8080...\") if err := http.ListenAndServe(\":8080\", mux); err != nil { log.Fatalf(\"HTTP server error: %v\", err) } } To Run: Navigate to examples/http/nethttp and run go run main.go. Clients can then connect by establishing an SSE connection to /events and sending POST requests to /message."},"title":"net/http"},"/examples/kitchen-sink/":{"data":{"":"","kitchen-sink-server-exampleskitchen-sinkserver#Kitchen Sink Server (\u003ccode\u003eexamples/kitchen-sink/server\u003c/code\u003e)":"This page details the example found in the /examples/kitchen-sink directory. As the name suggests, this example aims to demonstrate a wide variety of gomcp features working together in a single server application.\nThis includes:\nMultiple transport options (e.g., Stdio, HTTP+SSE, WebSocket) selectable via flags. Registration of multiple tools with different functionalities. Registration of resources and prompts. Handling of configuration, logging, and potentially other aspects. Kitchen Sink Server (examples/kitchen-sink/server) This example likely combines elements from many of the other examples, using command-line flags to configure which transport to use and potentially which features to enable.\nConceptual Snippets (Illustrative - check main.go for actual implementation):\npackage main import ( \"flag\" \"log\" \"net/http\" \"os\" // ... many other imports: server, protocol, types, stdio, sse, websocket, viper ... \"github.com/localrivet/gomcp/protocol\" // Added for protocol types \"github.com/localrivet/gomcp/server\" // Added for server types \"github.com/localrivet/gomcp/types\" // Added for types.Implementation ) // ... Define multiple tool handlers (handleEcho, handleCalc, handleReadFile, etc.) ... // ... Define resource providers ... func main() { // --- Command-Line Flags --- transportType := flag.String(\"transport\", \"stdio\", \"Transport type: stdio, http, websocket\") listenAddr := flag.String(\"listen\", \":8080\", \"Listen address for http/websocket\") // ... other flags ... flag.Parse() // --- Load Configuration (Optional, e.g., using Viper) --- // ... viper setup ... // --- Setup MCP Server --- serverInfo := types.Implementation{Name: \"kitchen-sink\", Version: \"0.1.0\"} opts := server.NewServerOptions(serverInfo) // Set capabilities based on features being enabled opts.Capabilities.Tools = \u0026protocol.ToolsCaps{ /* ... */ } opts.Capabilities.Resources = \u0026protocol.ResourcesCaps{ /* ... */ } // ... etc ... srv := server.NewServer(opts) // --- Register Multiple Capabilities --- log.Println(\"Registering capabilities...\") // Register echo tool // err := srv.RegisterTool(echoToolDef, handleEcho) ... // Register calculator tool // err = srv.RegisterTool(calcToolDef, handleCalc) ... // Register file reader tool // err = srv.RegisterTool(readFileToolDef, handleReadFile) ... // Register resources // err = srv.RegisterResource(fileResource, fileProvider) ... // Register prompts // err = srv.RegisterPrompt(examplePrompt) ... // --- Setup and Run Selected Transport --- log.Printf(\"Starting kitchen-sink server using %s transport...\", *transportType) var runErr error switch *transportType { case \"http\": sseServer := sse.NewServer(srv, opts.Logger) mux := http.NewServeMux() mux.HandleFunc(\"/events\", sseServer.HTTPHandler) mux.HandleFunc(\"/message\", srv.HTTPHandler) log.Printf(\" Listening on %s\", *listenAddr) runErr = http.ListenAndServe(*listenAddr, mux) case \"websocket\": wsFactory := websocket.NewFactory(srv, opts.Logger) mux := http.NewServeMux() mux.HandleFunc(\"/ws\", wsFactory.HTTPHandler) log.Printf(\" Listening on %s/ws\", *listenAddr) runErr = http.ListenAndServe(*listenAddr, mux) case \"stdio\": fallthrough // Default to stdio default: transport := stdio.NewStdioTransport(os.Stdin, os.Stdout, opts.Logger) runErr = srv.Run(transport) } // --- Handle Run Error --- if runErr != nil { log.Fatalf(\"Server error: %v\", runErr) } log.Println(\"Server stopped.\") } To Run:\nNavigate to examples/kitchen-sink/server. Build: go build -o kitchen-sink-server Run with desired transport: ./kitchen-sink-server -transport stdio ./kitchen-sink-server -transport http -listen :8080 ./kitchen-sink-server -transport websocket -listen :9090 This example serves as a comprehensive reference for integrating various gomcp components. Consult the main.go file for the full implementation details."},"title":"Kitchen Sink"},"/examples/rate-limit/":{"data":{"":"","rate-limited-server-examplesrate-limitserver#Rate-Limited Server (\u003ccode\u003eexamples/rate-limit/server\u003c/code\u003e)":"This page details the example found in the /examples/rate-limit directory, demonstrating how to implement rate limiting for an MCP server, typically using middleware in the transport layer.\nRate limiting is crucial for preventing abuse and ensuring fair usage of server resources. This example likely uses a token bucket algorithm, possibly via the golang.org/x/time/rate package.\nRate-Limited Server (examples/rate-limit/server) This example adds middleware to the HTTP+SSE transport to limit the rate at which clients can send messages (e.g., tools/call requests).\nKey parts:\npackage main import ( \"log\" \"net\" // Added for net.SplitHostPort \"net/http\" \"sync\" \"time\" \"golang.org/x/time/rate\" // For rate limiting // ... other imports: server, protocol, types, sse ... \"github.com/localrivet/gomcp/server\" // Added for server types \"github.com/localrivet/gomcp/types\" // Added for types.Implementation ) // Simple IP-based rate limiter store var ( visitors = make(map[string]*rate.Limiter) mu sync.Mutex ) // Function to get or create a limiter for an IP address func getVisitorLimiter(ip string) *rate.Limiter { mu.Lock() defer mu.Unlock() limiter, exists := visitors[ip] if !exists { // Example: Allow 1 request every 2 seconds (burst of 3) limiter = rate.NewLimiter(rate.Every(2*time.Second), 3) visitors[ip] = limiter } return limiter } // Rate limiting middleware func rateLimitMiddleware(next http.Handler) http.Handler { return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) { // Get client IP (simplified, consider X-Forwarded-For in real apps) ip := r.RemoteAddr // For simplicity, just taking the host part if port is present if host, _, err := net.SplitHostPort(ip); err == nil { ip = host } limiter := getVisitorLimiter(ip) if !limiter.Allow() { log.Printf(\"Rate limit exceeded for %s on %s\", ip, r.URL.Path) http.Error(w, \"Too Many Requests\", http.StatusTooManyRequests) return // Stop processing if rate limit exceeded } // Allow request if within limit next.ServeHTTP(w, r) }) } func main() { // 1. Setup MCP Server (as usual) serverInfo := types.Implementation{Name: \"rate-limit-server\", Version: \"0.1.0\"} opts := server.NewServerOptions(serverInfo) srv := server.NewServer(opts) // Register tools, etc. // 2. Create SSE Transport Server sseServer := sse.NewServer(srv, opts.Logger) // 3. Setup HTTP Handlers with Middleware mux := http.NewServeMux() // Apply rate limiting middleware *only* to the message handler // (SSE connection itself is usually not rate-limited this way) rateLimitedMessageHandler := rateLimitMiddleware(http.HandlerFunc(srv.HTTPHandler)) mux.Handle(\"/message\", rateLimitedMessageHandler) mux.HandleFunc(\"/events\", sseServer.HTTPHandler) // SSE handler without rate limit // 4. Start HTTP Server log.Println(\"Starting Rate-Limited MCP server on :8080...\") if err := http.ListenAndServe(\":8080\", mux); err != nil { log.Fatalf(\"HTTP server error: %v\", err) } } To Run:\nNavigate to examples/rate-limit/server and run go run main.go. Use an MCP client (like the one in examples/rate-limit/client) to send multiple requests quickly to /message. Observe that after a few successful requests, subsequent requests will receive a 429 Too Many Requests error until the rate limit interval passes. Note: This is a basic IP-based limiter. Real-world applications might require more sophisticated rate limiting based on authenticated users, API keys, or specific resources being accessed."},"title":"Rate Limiting"},"/examples/websocket/":{"data":{"":"","websocket-server-exampleswebsocketserver#WebSocket Server (\u003ccode\u003eexamples/websocket/server\u003c/code\u003e)":"This page details the example found in the /examples/websocket directory, demonstrating how to set up an MCP server using the WebSocket transport.\nThe WebSocket transport provides full-duplex communication over a single TCP connection, allowing both client and server to send messages at any time. The transport/websocket package provides the necessary components.\nWebSocket Server (examples/websocket/server) This example shows how to integrate the websocket.Factory with Go’s standard net/http server to handle WebSocket connections.\nKey parts:\npackage main import ( \"log\" \"net/http\" // ... other imports: server, protocol, types ... \"github.com/localrivet/gomcp/transport/websocket\" ) func main() { // 1. Setup MCP Server (like in basic examples) serverInfo := types.Implementation{Name: \"websocket-server\", Version: \"0.1.0\"} opts := server.NewServerOptions(serverInfo) // opts.Capabilities... // Set capabilities srv := server.NewServer(opts) // srv.RegisterTool(...) // Register tools, resources, etc. // 2. Create a WebSocket Transport Factory // The factory creates a new transport instance for each incoming connection wsFactory := websocket.NewFactory(srv, opts.Logger) // Pass the MCP server instance // 3. Setup HTTP Handler for WebSocket Upgrades mux := http.NewServeMux() // The factory's HTTPHandler upgrades connections and runs the transport mux.HandleFunc(\"/ws\", wsFactory.HTTPHandler) // 4. Start HTTP Server log.Println(\"Starting WebSocket MCP server on :8080/ws...\") if err := http.ListenAndServe(\":8080\", mux); err != nil { log.Fatalf(\"HTTP server error: %v\", err) } } To Run: Navigate to examples/websocket/server and run go run main.go. An MCP client capable of communicating over WebSockets can then connect to ws://localhost:8080/ws.\nNote: Unlike the SSE+HTTP transport which uses separate endpoints for events and messages, the WebSocket transport typically uses a single endpoint (/ws in this case) for the entire bidirectional communication after the initial HTTP upgrade request."},"title":"WebSocket"},"/license/":{"data":{"":"Copyright (c) 2025 localrivet\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."},"title":"MIT License"}}